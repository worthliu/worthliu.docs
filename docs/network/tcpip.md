## TCP/IP

### 网络协议

`TCP/IP`(Transmission Control Protocol/Internet Protocol)，传输控制协议/因特网互联协议，这个协议族群里还有HTTP、HTTPS、FTP、SMTP、UDP、ARP、PPP、IEEE802.x等。

>+ `链路层`：链路层以字节为单位把`0`与`1`进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据；
+ `网络层`：根据IP定义网络地址，区分网段。
  + 子网内根据地址解析协议（`ARP`）进行`MAC`寻址，子网外进行路由转发数据包，这个数据包即IP数据包；
+ `传输层`：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。
  + `UDP`：UDP只是IP数据包上增加端口等部分信息，是面向无连接的，是不可靠传输，多用于视屏通信、电话会议等（即使少一帧数据也无妨）
  + `TCP`：`TCP`是面向连接的，所谓面向连接，是一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一条固定的通路承载着数据的可靠传输；
+ `应用层`：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据；

>程序在发送消息时，应用按既定的协议打包数据，随后由`传输层`加上双方的`端口号`，由`网络层`加上双方的`IP地址`，有`链路层`加上双方的`MAC地址`，并将`数据`拆分成`数据帧`，经过多个路由器和网关后，到达目标机器。简而言之，就是按`“端口->IP地址->MAC地址”`，这样的路径进行数据的封装和发送，解包的时候反过来操作即可；

![messageStructure](/images/messageStructure.png)

### `IP协议`
`IP协议`是面向无连接、无状态的没有额外的机制保证发送的包是否有序到达；

`IP协议`，首先规定出`IP`地址格式，该地址相当与在逻辑意义上进行了网段的划分，给每台计算机额外设置了一个唯一的详细地址。

>既然链路层可以通过唯一的MAC地址找到机器，为什么还需要通过唯一的IP地址再来标识？
+ 简单而言，在世界范围内，不可能通过广播的方式，从数以千万的计算机里找到目标MAC地址的计算机而不超时；

IP地址属于网络层，主要功能在WLAN内进行路由寻址，选择最佳路由。

协议结构比较简单，其中数据包的生存时间，即TTL(Time To Live)，该字段表示IP报文被路由器丢弃之前可经过的最多的路由总数。

**TTL初始值由源主机设置后，数据包在传输过程中每经过一个路由器TTL值则减1，当该字段为0时，数据包被丢弃，并发送ICMP报文通知源主机，以防止源主机无休止地发送报文。**

ICMP（Internet Control Message Protocol），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。

ICMP虽然并不传输用户数据，但是对评估网络健康状态非常重要，经常使用的ping、tracert命令就是基于ICMP检测网络状态的有力工具。

### `TCP`建立连接

传输控制协议（Transmission Control Protocol，TCP），是一种面向连接、确保数据在端到端间可靠传输的协议。

面向连接是指在发送数居前，需要先建立一条虚拟的链路，然后让数据在这个链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形；


>三次握手建立连接步骤：
+ A机器发出一个数据包并将`SYN`置1，表示希望建立连接。这个包中的序列号假设是X；
+ B机器收到A机器发过来的数据包后，通过`SYN`得到这是一个建立连接的请求，于是发送一个响应包并将`SYN`和`ACK`标记都置1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的`SYN`。在TCP中，`SYN`被当作数据部分的一个字节；
+ A收到B的响应包后需进行确认，确认包中将`ACK`置1，并将确认序列号设置为y+1，表示收到了来自B的`SYN`；


>**为什么需要3次握手?**
+ `信息对等`,握手操作对于通讯双方而言,是用于确认双方相应的通讯的能力(`自己发报文`,`自己收报文`,`对方发报文`,`对方收报文`);
+ `防止出现请求超时导致脏连接`,TTL网络报文的生存时间往往会超过TCP请求超时时间,如果两次握手就可以创建连接,传输数据并释放连接后,第一个超时的连接请求才到到达目标机器的话,目标机器会以为是请求机器创建新连接的请求,然后确认同意创建连接.


>+ 从编程的角度看,TCP连接的建立是通过文件描述符(File Descriptor,fd)完成的.
+ 通过创建套接字获得一个fd,然后服务端和客户端需要基于所获得的fd调用不同的函数分别进入监听状态和发起连接请求
+ 由于fd的数量将决定服务端进程所能建立连接的数量,对于大规模分布式服务来说,当fd不足时就会出现"open too
 many files"错误而使得无法建立更多的连接.
+ 为此,需要注意调整服务端进程和操作系统所支持的最大文件句柄数;

>**通过使用`ulimit -n`命令来查看单个进程可以打开文件句柄的数量.**


查看当前系统各个进程产生了多少句柄:

```
lsof -n | awk '{print $2}' | sort | uniq -c | sort -nr | more
```

>+ TCP在协议层面支持Keep Alive功能,即隔段时间通过向对方发送数据表示连接处于健康状态.
+ 不少服务将确保连接健康的行为放到了应用层,通过定期发送心跳包检查连接的健康度.一旦心跳包出现异常不仅会主动关闭连接,还会回收与连接相关的其他用于提供服务的资源,确保系统资源最大限度地被有效利用;

### `TCP`断开连接

TCP是全双工通信,双方都能作为数据的发送方和接收方,但TCP连接也会有断开的时间.建立连接只有三次,而挥手断开则需要四次;

**由于断开连接,需要等待已接受的数据处理完毕,才能断开,因此双方都要处于半关闭状态,等待双方作答,方可真正的关闭连接;**

+ A机器想要关闭连接,则待本方数据发送完毕后,传递`FIN`信号给B机器;
+ B机器应答`ACK`,告诉A机器可以断开,但是需要等B机器处理完数据,再主动给A机器发送`FIN`信号;
  + A机器处于半关闭状态(`FIN_WAIT_2`),无法再发送新的数据;
+ B机器做好连接关闭前的准备工作后,发送`FIN`给A机器;
  + B机器也进入半关闭状态(`CLOSE_WAIT`)
+ A机器发送针对B机器`FIN`的`ACK`后,进入`TIME-WAIT`状态;
  + 经过`2MSL(Maximun Segement Lifetime)`后,没有收到B机器传来的报文,则确立B机器已经收到A机器最后发送的`ACK`指令,此时`TCP`连接正式释放;

>+ `TIME_WAIT` : 主动要求关闭的机器表示收到了对方的`FIN`报文,并发送出了`ACK`报文,进入`TIME_WAIT`状态,等`2MSL`后即可进入到`CLOSED`状态;
  + 如果`FIN_WAIT_1`状态下,同时收到带`FIN`标志和`ACK`标志的报文时,可以直接进入`TIME_WAIT`状态,而无须经过`FIN_WAIT_2`状态;
+ `CLOSE_WAIT` : 被动要求关闭的机器收到对方请求关闭连接的`FIN`报文,在第一次`ACK`应答后,马上进入`CLOSE_WAIT`状态.
  + 这种状态其实表示在等待关闭,并且通知应用程序发送剩余数据,处理现场信息,关闭相关资源;