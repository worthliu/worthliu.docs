### 介绍

`HTTP`是`Hyper Text Transfer Protocol`（超文本传输协议）的缩写。它的发展是万维网协会（`World Wide Web Consortium`）和`Internet`工作小组`IETF`（`Internet Engineering Task Force`）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。

其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1（可以重用TCP连接）。

`HTTP`协议（`HyperText Transfer Protocol`，超文本传输协议）是用于从`WWW`服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。

`HTTP`是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。

**`HTTP`是一个无状态的协议。**

### 在TCP/IP协议栈中的位置
`HTTP`协议通常承载于`TCP`协议之上，有时也承载于`TLS`或`SSL`协议层之上，这个时候，就成了我们常说的`HTTPS`。

![http.png](/images/http.png)

**默认`HTTP`的端口号为`80`，`HTTPS`的端口号为`443`。**

### HTTP的请求响应模型
**HTTP协议永远都是客户端发起请求，服务器回送响应。**  

这样就限制了使用`HTTP`协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。
`HTTP`协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。

>**工作流程：一次`HTTP`操作称为一个事务，其工作过程可分为四步**
1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，`HTTP`的工作开始。
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（`URL`）、协议版本号，后边是`MIME`信息包括请求修饰符、客户机信息和可能的内容。
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是`MIME`信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由`HTTP`自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

1. host头域
  + Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。
  + `HTTP/1.1`请求必须包含主机头域，否则系统会以400状态码返回。
```
HOST:image.baidu.com\r\n
```

2. Referer头域
  + Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。
  + 他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。
  + 如果指定的是部分uri地址，则此地址应该是一个相对地址。
```
Referer:http://image.baidu.com/\r\n
```

3. User-Agent头域
  + User-Agent头域的内容包含发出请求的用户信息。
```
User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
```

4. Cache-Control头域
  + Cache-Control指定请求和响应遵循的缓存机制。
  + 在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。
  + 请求时的缓存指令包括`no-cache`、`no-store`、`max-age`、`max-stale`、`min-fresh`、`only-if-cached，响应消息中的指令包括public`、`private`、`no-cache`、`no-store`、`no-transform`、`must-revalidate`、`proxy-revalidate`、`max-age`。
```
cache-control: public, max-age=14400
```
5. Date头域
  + Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。
  + Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。  
```
date: Wed, 19 Dec 2018 01:50:42 GMT
```

### HTTP的几个重要概念

>1. **连接**：`Connection` 一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。
  + 在`http1.1`，`request`和`reponse`头中都有可能出现一个`connection`的头，此`header`的含义是当`client`和`server`通信时对于长链接如何进行处理。
  + 在`http1.1`中，`client`和`server`都是默认对方支持长链接的， 如果`client`使用`http1.1`协议，但又不希望使用长链接，则需要在`header`中指明`connection`的值为`close`；
  + 如果`server`方也不想支持长链接，则在`response`中也需要明确说明`connection`的值为`close`。不论`request`还是`response`的`header`中包含了值为`close`的`connection`，都表明当前正在使用的`tcp`链接在当天请求处理完毕后会被断掉。以后`client`再进行新的请求时就必须创建新的`tcp`链接了。
2. **消息**：`Message` HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。
3. **请求**：`Request` 一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。
4. **响应**：`Response` 一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。
5. **资源**：`Resource` 由URI标识的网络数据对象或服务。
6. **实体**：`Entity` 数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。
7. **客户机**：`Client` 一个为发送请求目的而建立连接的应用程序。
8. **用户代理**：`UserAgent` 初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。
9. **服务器**：`Server` 一个接受连接并对请求返回信息的应用程序。
10. **源服务器**：`Originserver` 是一个给定资源可以在其上驻留或被创建的服务器。
11. **代理**：`Proxy` 一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。
  + 请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。
  + 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。
12. **网关**：`Gateway` 一个作为其它服务器中间媒介的服务器。
  + 与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。
  + 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。
13. **通道**：`Tunnel` 是作为两个连接中继的中介程序。
  + 一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。
  + 当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。
14. **缓存**：`Cache` 反应信息的局域存储。

## `HTTP`协议定义方法（`GET`，`POST`，`PUT`，`DELETE`）

**http协议是基于`tcp`协议的应用层协议，`tcp`协议作为可靠的传输层协议，因此`http`协议也是可靠的；**

`Http`定义了与服务器交互的不同方法，最基本的方法有4种，分别是`GET`，`POST`，`PUT`，`DELETE`。

`URL`全称是资源描述符；我们可以这样认为：一个`URL`地址，它用于描述一个网络上的资源，而HTTP中的`GET`，`POST`，`PUT`，`DELETE`就对应着对这个资源的查，改，增，删4个操作;

### GET/POST

**GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。**

1. 根据`HTTP`规范，GET用于信息获取，而且应该是安全的和幂等的。
  + 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，`GET` 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
　　* 注意：这里安全的含义仅仅是指是非修改信息。
  + 幂等的意味着对同一URL的多个请求应该返回同样的结果。
2. 根据`HTTP`规范，`POST`表示可能修改变服务器上的资源的请求：
   + `HTTP`规范中GET和`POST`的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：
	1. 很多人贪方便，更新资源时用了`GET`，因为用`POST`必须要到FORM（表单），这样会麻烦一点。
	2. 对资源的增，删，改，查操作，其实都可以通过`GET/POST`完成，不需要用到`PUT`和`DELETE`。
	3. 另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的`Web MVC`框架基本上都只支持`GET`和`POST`两种`HTTP`方法，而不支持`PUT`和`DELETE`方法。

### GET和POST的区别
从表面现像上面看看GET和POST的区别：

>1. GET与POST请求数据区别
+ `GET`请求的数据会附在`URL`之后（就是把数据放置在HTTP协议头中），以?分割`URL`和传输数据，参数之间以`&`相连；
  + 如：`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD`。
  + 如果数据是英文字母/数字，原样发送，
  + 如果是空格，转换为+，
  + 如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：`%E4%BD%A0%E5%A5%BD`，
  + 其中`％XX`中的`XX`为该符号以`16进制`表示的`ASCII`。
+ POST把提交的数据则放置在是HTTP包的包体中。

>2. GET与`POST`传送数据大小限制
+ 首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。
  + 而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
  + IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
　+ **注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度**。
+ 理论上讲，`POST`是没有大小限制的，HTTP协议规范也没有进行大小限制，说“`POST`数据量存在80K/100K的大小限制”是不准确的，`POST`数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。

>3. `POST`的安全性要比GET的安全性高
+ 通过GET提交数据，用户名和密码将明文出现在URL上，因为
  + 登录页面有可能被浏览器缓存，
  + 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。(跨站请求攻击，一般做法是进行输入内容转义)

### PUT：  

>**PUT方法请求以提供的Request-URI存储封装的实体。**
+ 如果`Request-URI`引用已经存在的资源，该封装实体应该被认作原始服务器存储的修改版本。
+ 如果`Request-URI`没有指向已存在的资源， 且该URI可以被请求的用户代理定义为新的资源， 则原始服务器可以用该 URI创建资源。
+ 如果创建了新的资源，则原始服务器必须通过 `201`（Created）响应提示用户代理。
+ 如果修改了已存在的资源，则应该发送`200`（OK）或 `204`（No Content）响应代码来表示成功完成了请求。
+ 如果不能按`Request-URI`创建或修改资源，则应该给出适当的错误响应以反映出问题的性质。实体的接受方不能乎略任何不理解或没有实现的 Content-*（如Content-Range）头部，在这种情况下必须返回 501（Not Implemented）响应。 
+ 如果请求通过缓冲服务器`Request-URI`标识出一个或多个缓冲的实体，则应该认为这些实体过期了。该方法的响应不可缓存。

#### POST和PUT请求间的基本区别反映在`Request-URI`的不同意义。
+ `POST`请求中URI标识的资源将处理封装的实体。该资源可能是数据接收过程、其它协议的网关或接受注解的独立实体。
+ `PUT`请求中的URI标识请求封装的实体——用户代理知道该 URI是目标且服务器不能试图将该请求应用到其它资源上。
 
如果服务器希望该请求应用到不同的`URI`上，则它必须发送`301（Moved Permanently）`请求；这时客户代理可以自己决定是否要重定向该请求。 

可以用许多不同的`URI`标识同个资源。例如，一篇文章可以有标识为“当前版本”的`URI`，它独立于标识每个特别版本的`URI`。在这种情况下，使用通用`URI`的`PUT`请求可能造成原始服务器定义的一些不同URI的结果。 

**`HTTP/1.1`没有定义PUT方法如何影响原始服务器的状态。  除了其它特殊实体头部的规定，`PUT`请求中的实体头部应该应用到`PUT`创建或修改的资源上。**

### DELETE
**DELETE 方法请求原始服务器删除Request-URI 标识的资源。**

原始服务器可在人为干涉下（或其它意思）屏闭该方法。客户端不能确保该操作已经提交，即使原始服务器发出的状态码表明动作已经成功完成也如此。然而，在给出响应的时候，服务器不应该表示成功，除非它试图删除该资源或将它移动到不可访问的位置。 
    
>+ 如果响应包含描述状态的实体，成功响应应该是200（OK）。如果动作没有实施，则是202（Accepted）。如果动作已经实施但响应不包含实体，则是 204（No Content）。 
+ 如果请求通过缓冲服务器，且Request-URI标识一个或多个当前缓存的实体，则应该认为这些实体已经过期。该方法的响应不可缓存。