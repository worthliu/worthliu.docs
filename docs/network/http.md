### 介绍

`HTTP`是`Hyper Text Transfer Protocol`（超文本传输协议）的缩写。它的发展是万维网协会（`World Wide Web Consortium`）和`Internet`工作小组`IETF`（`Internet Engineering Task Force`）合作的结果，（他们）最终发布了一系列的RFC，RFC 1945定义了HTTP/1.0版本。

其中最著名的就是RFC 2616。RFC 2616定义了今天普遍使用的一个版本——HTTP 1.1（可以重用TCP连接）。

`HTTP`协议（`HyperText Transfer Protocol`，超文本传输协议）是用于从`WWW`服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等。

`HTTP`是一个应用层协议，由请求和响应构成，是一个标准的客户端服务器模型。

**`HTTP`是一个无状态的协议。**

### 在TCP/IP协议栈中的位置
`HTTP`协议通常承载于`TCP`协议之上，有时也承载于`TLS`或`SSL`协议层之上，这个时候，就成了我们常说的`HTTPS`。

![http.png](/images/http.png)

**默认`HTTP`的端口号为`80`，`HTTPS`的端口号为`443`。**

### HTTP的请求响应模型
**HTTP协议永远都是客户端发起请求，服务器回送响应。**  

这样就限制了使用`HTTP`协议，无法实现在客户端没有发起请求的时候，服务器将消息推送给客户端。
`HTTP`协议是一个无状态的协议，同一个客户端的这次请求和上次请求是没有对应关系。

>**工作流程：一次`HTTP`操作称为一个事务，其工作过程可分为四步**
1. 首先客户机与服务器需要建立连接。只要单击某个超级链接，`HTTP`的工作开始。
2. 建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（`URL`）、协议版本号，后边是`MIME`信息包括请求修饰符、客户机信息和可能的内容。
3. 服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是`MIME`信息包括服务器信息、实体信息和可能的内容。
4. 客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。

如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，有显示屏输出。对于用户来说，这些过程是由`HTTP`自己完成的，用户只要用鼠标点击，等待信息显示就可以了。

1. host头域
  + Host头域指定请求资源的Intenet主机和端口号，必须表示请求url的原始服务器或网关的位置。
  + `HTTP/1.1`请求必须包含主机头域，否则系统会以400状态码返回。
```
HOST:image.baidu.com\r\n
```

2. Referer头域
  + Referer头域允许客户端指定请求uri的源资源地址，这可以允许服务器生成回退链表，可用来登陆、优化cache等。
  + 他也允许废除的或错误的连接由于维护的目的被追踪。如果请求的uri没有自己的uri地址，Referer不能被发送。
  + 如果指定的是部分uri地址，则此地址应该是一个相对地址。
```
Referer:http://image.baidu.com/\r\n
```

3. User-Agent头域
  + User-Agent头域的内容包含发出请求的用户信息。
```
User-Agent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36
```

4. Cache-Control头域
  + Cache-Control指定请求和响应遵循的缓存机制。
  + 在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。
  + 请求时的缓存指令包括`no-cache`、`no-store`、`max-age`、`max-stale`、`min-fresh`、`only-if-cached，响应消息中的指令包括public`、`private`、`no-cache`、`no-store`、`no-transform`、`must-revalidate`、`proxy-revalidate`、`max-age`。
```
cache-control: public, max-age=14400
```
5. Date头域
  + Date头域表示消息发送的时间，时间的描述格式由rfc822定义。例如，Date:Mon,31Dec200104:25:57GMT。
  + Date描述的时间表示世界标准时，换算成本地时间，需要知道用户所在的时区。  
```
date: Wed, 19 Dec 2018 01:50:42 GMT
```

### HTTP的几个重要概念

>1. **连接**：`Connection` 一个传输层的实际环流，它是建立在两个相互通讯的应用程序之间。
  + 在`http1.1`，`request`和`reponse`头中都有可能出现一个`connection`的头，此`header`的含义是当`client`和`server`通信时对于长链接如何进行处理。
  + 在`http1.1`中，`client`和`server`都是默认对方支持长链接的， 如果`client`使用`http1.1`协议，但又不希望使用长链接，则需要在`header`中指明`connection`的值为`close`；
  + 如果`server`方也不想支持长链接，则在`response`中也需要明确说明`connection`的值为`close`。不论`request`还是`response`的`header`中包含了值为`close`的`connection`，都表明当前正在使用的`tcp`链接在当天请求处理完毕后会被断掉。以后`client`再进行新的请求时就必须创建新的`tcp`链接了。
2. **消息**：`Message` HTTP通讯的基本单位，包括一个结构化的八元组序列并通过连接传输。
3. **请求**：`Request` 一个从客户端到服务器的请求信息包括应用于资源的方法、资源的标识符和协议的版本号。
4. **响应**：`Response` 一个从服务器返回的信息包括HTTP协议的版本号、请求的状态(例如“成功”或“没找到”)和文档的MIME类型。
5. **资源**：`Resource` 由URI标识的网络数据对象或服务。
6. **实体**：`Entity` 数据资源或来自服务资源的回映的一种特殊表示方法，它可能被包围在一个请求或响应信息中。一个实体包括实体头信息和实体的本身内容。
7. **客户机**：`Client` 一个为发送请求目的而建立连接的应用程序。
8. **用户代理**：`UserAgent` 初始化一个请求的客户机。它们是浏览器、编辑器或其它用户工具。
9. **服务器**：`Server` 一个接受连接并对请求返回信息的应用程序。
10. **源服务器**：`Originserver` 是一个给定资源可以在其上驻留或被创建的服务器。
11. **代理**：`Proxy` 一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。
  + 请求是通过可能的翻译在内部或经过传递到其它的服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。
  + 代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处理没有被用户代理完成的请求。
12. **网关**：`Gateway` 一个作为其它服务器中间媒介的服务器。
  + 与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。
  + 网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。
13. **通道**：`Tunnel` 是作为两个连接中继的中介程序。
  + 一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继的连接两端关闭时，通道便消失。
  + 当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。
14. **缓存**：`Cache` 反应信息的局域存储。

## `HTTP`协议定义方法（`GET`，`POST`，`PUT`，`DELETE`）

**http协议是基于`tcp`协议的应用层协议，`tcp`协议作为可靠的传输层协议，因此`http`协议也是可靠的；**

`Http`定义了与服务器交互的不同方法，最基本的方法有4种，分别是`GET`，`POST`，`PUT`，`DELETE`。

`URL`全称是资源描述符；我们可以这样认为：一个`URL`地址，它用于描述一个网络上的资源，而HTTP中的`GET`，`POST`，`PUT`，`DELETE`就对应着对这个资源的查，改，增，删4个操作;

### GET/POST

**GET一般用于获取/查询资源信息，而POST一般用于更新资源信息。**

1. 根据`HTTP`规范，GET用于信息获取，而且应该是安全的和幂等的。
  + 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，`GET` 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
　　* 注意：这里安全的含义仅仅是指是非修改信息。
  + 幂等的意味着对同一URL的多个请求应该返回同样的结果。
2. 根据`HTTP`规范，`POST`表示可能修改变服务器上的资源的请求：
   + `HTTP`规范中GET和`POST`的一些原理性的问题。但在实际的做的时候，很多人却没有按照HTTP规范去做，导致这个问题的原因有很多，比如说：
	1. 很多人贪方便，更新资源时用了`GET`，因为用`POST`必须要到FORM（表单），这样会麻烦一点。
	2. 对资源的增，删，改，查操作，其实都可以通过`GET/POST`完成，不需要用到`PUT`和`DELETE`。
	3. 另外一个是，早期的Web MVC框架设计者们并没有有意识地将URL当作抽象的资源来看待和设计，所以导致一个比较严重的问题是传统的`Web MVC`框架基本上都只支持`GET`和`POST`两种`HTTP`方法，而不支持`PUT`和`DELETE`方法。

### GET和POST的区别
从表面现像上面看看GET和POST的区别：

>1. GET与POST请求数据区别
+ `GET`请求的数据会附在`URL`之后（就是把数据放置在HTTP协议头中），以?分割`URL`和传输数据，参数之间以`&`相连；
  + 如：`login.action?name=hyddd&password=idontknow&verify=%E4%BD%A0%E5%A5%BD`。
  + 如果数据是英文字母/数字，原样发送，
  + 如果是空格，转换为+，
  + 如果是中文/其他字符，则直接把字符串用BASE64加密，得出如：`%E4%BD%A0%E5%A5%BD`，
  + 其中`％XX`中的`XX`为该符号以`16进制`表示的`ASCII`。
+ POST把提交的数据则放置在是HTTP包的包体中。

>2. GET与`POST`传送数据大小限制
+ 首先是"GET方式提交的数据最多只能是1024字节"，因为GET是通过URL提交数据，那么GET可提交的数据量就跟URL的长度有直接关系了。
  + 而实际上，URL不存在参数上限的问题，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。
  + IE对URL长度的限制是2083字节(2K+35)。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。
　+ **注意这是限制是整个URL长度，而不仅仅是你的参数值数据长度**。
+ 理论上讲，`POST`是没有大小限制的，HTTP协议规范也没有进行大小限制，说“`POST`数据量存在80K/100K的大小限制”是不准确的，`POST`数据是没有限制的，起限制作用的是服务器的处理程序的处理能力。

>3. `POST`的安全性要比GET的安全性高
+ 通过GET提交数据，用户名和密码将明文出现在URL上，因为
  + 登录页面有可能被浏览器缓存，
  + 其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用GET提交数据还可能会造成Cross-site request forgery攻击。(跨站请求攻击，一般做法是进行输入内容转义)

### PUT：  

>**PUT方法请求以提供的Request-URI存储封装的实体。**
+ 如果`Request-URI`引用已经存在的资源，该封装实体应该被认作原始服务器存储的修改版本。
+ 如果`Request-URI`没有指向已存在的资源， 且该URI可以被请求的用户代理定义为新的资源， 则原始服务器可以用该 URI创建资源。
+ 如果创建了新的资源，则原始服务器必须通过 `201`（Created）响应提示用户代理。
+ 如果修改了已存在的资源，则应该发送`200`（OK）或 `204`（No Content）响应代码来表示成功完成了请求。
+ 如果不能按`Request-URI`创建或修改资源，则应该给出适当的错误响应以反映出问题的性质。实体的接受方不能乎略任何不理解或没有实现的 Content-*（如Content-Range）头部，在这种情况下必须返回 501（Not Implemented）响应。 
+ 如果请求通过缓冲服务器`Request-URI`标识出一个或多个缓冲的实体，则应该认为这些实体过期了。该方法的响应不可缓存。

#### POST和PUT请求间的基本区别反映在`Request-URI`的不同意义。
+ `POST`请求中URI标识的资源将处理封装的实体。该资源可能是数据接收过程、其它协议的网关或接受注解的独立实体。
+ `PUT`请求中的URI标识请求封装的实体——用户代理知道该 URI是目标且服务器不能试图将该请求应用到其它资源上。
 
如果服务器希望该请求应用到不同的`URI`上，则它必须发送`301（Moved Permanently）`请求；这时客户代理可以自己决定是否要重定向该请求。 

可以用许多不同的`URI`标识同个资源。例如，一篇文章可以有标识为“当前版本”的`URI`，它独立于标识每个特别版本的`URI`。在这种情况下，使用通用`URI`的`PUT`请求可能造成原始服务器定义的一些不同URI的结果。 

**`HTTP/1.1`没有定义PUT方法如何影响原始服务器的状态。  除了其它特殊实体头部的规定，`PUT`请求中的实体头部应该应用到`PUT`创建或修改的资源上。**

### DELETE
**DELETE 方法请求原始服务器删除Request-URI 标识的资源。**

原始服务器可在人为干涉下（或其它意思）屏闭该方法。客户端不能确保该操作已经提交，即使原始服务器发出的状态码表明动作已经成功完成也如此。然而，在给出响应的时候，服务器不应该表示成功，除非它试图删除该资源或将它移动到不可访问的位置。 
    
>+ 如果响应包含描述状态的实体，成功响应应该是200（OK）。如果动作没有实施，则是202（Accepted）。如果动作已经实施但响应不包含实体，则是 204（No Content）。 
+ 如果请求通过缓冲服务器，且Request-URI标识一个或多个当前缓存的实体，则应该认为这些实体已经过期。该方法的响应不可缓存。

## HTTP状态码

>+ 1** - 信息提示：这些状态代码表示临时的响应。客户端在收到常规响应之前，应准备接收一个或多个 1xx 响应。
  + 100 - Continue 初始的请求已经接受，客户应当继续发送请求的其余部分。（新）
  + 101 - Switching Protocols 服务器将遵从客户的请求转换到另外一种协议。（新）
+ 2** - 成功：这类状态代码表明服务器成功地接受了客户端请求。
  + 200 - OK 一切正常，对GET和POST请求的应答文档跟在后面。
  + 201 - Created 服务器已经创建了文档，Location头给出了它的URL。
  + 202 - Accepted 已经接受请求，但处理尚未完成。
  + 203 - Non-Authoritative Information 文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息（新）。
  + 204 - No Content 没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的。
  + 205 - Reset Content 没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容（新）。
  + 206 - Partial Content 客户发送了一个带有Range头的GET请求，服务器完成了它（新）。
+ 3** - 重定向：客户端浏览器必须采取更多操作来实现请求。例如，浏览器可能不得不请求服务器上的不同的页面，或通过代理服务器重复该请求。
  + 300 - Multiple Choices 客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
  + 301 - Moved Permanently 客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。
  + 302 - Found 类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。注意，在HTTP1.0中对应的状态信息是“Moved Temporatily”。出现该状态代码时，浏览器能够自动访问新的URL，因此它是一个很有用的状态代码。注意这个状态代码有时候可以和301替换使用。例如，如果浏览器错误地请求 http://host/~user （缺少了后面的斜杠），有的服务器返回301，有的则返回302。严格地说，我们只能假定只有当原来的请求是GET时浏览器才会自动重定向。请参见 307。
  + 303 - See Other 类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取（新）。
  + 304 - Not Modified 客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。
  + 305 - Use Proxy 客户请求的文档应该通过Location头所指明的代理服务器提取（新）。
  + 307 - Temporary Redirect 和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码：当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。（新）
+ 4** - 客户端错误：发生错误，客户端似乎有问题。例如，客户端请求不存在的页面，客户端未提供有效的身份验证信息。
  + 400 - Bad Request 请求出现语法错误。
  + 401 - Unauthorized 访问被拒绝，客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。IIS 定义了许多不同的 401 错误，它们指明更为具体的错误原因。这些具体的错误代码在浏览器中显示，但不在 IIS 日志中显示：
    + 401.1 - 登录失败。
    + 401.2 - 服务器配置导致登录失败。
    + 401.3 - 由于 ACL 对资源的限制而未获得授权。
    + 401.4 - 筛选器授权失败。
    + 401.5 - ISAPI/CGI 应用程序授权失败。
    + 401.7 – 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。
  + 403 - Forbidden 资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。禁止访问：IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：
    + 403.1 - 执行访问被禁止。
    + 403.2 - 读访问被禁止。
    + 403.3 - 写访问被禁止。
    + 403.4 - 要求 SSL。
    + 403.5 - 要求 SSL 128。
    + 403.6 - IP 地址被拒绝。
    + 403.7 - 要求客户端证书。
    + 403.8 - 站点访问被拒绝。
    + 403.9 - 用户数过多。
    + 403.10 - 配置无效。
    + 403.11 - 密码更改。
    + 403.12 - 拒绝访问映射表。
    + 403.13 - 客户端证书被吊销。
    + 403.14 - 拒绝目录列表。
    + 403.15 - 超出客户端访问许可。
    + 403.16 - 客户端证书不受信任或无效。
    + 403.17 - 客户端证书已过期或尚未生效。
    + 403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。
    + 403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。
    + 403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。
  + 404 - Not Found 无法找到指定位置的资源。这也是一个常用的应答。
    + 404.0 -（无） – 没有找到文件或目录。
    + 404.1 - 无法在所请求的端口上访问 Web 站点。
    + 404.2 - Web 服务扩展锁定策略阻止本请求。
    + 404.3 - MIME 映射策略阻止本请求。
  + 405 - Method Not Allowed 请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用，用来访问本页面的 HTTP 谓词不被允许（方法不被允许）（新）
  + 406 - Not Acceptable 指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容，客户端浏览器不接受所请求页面的 MIME 类型（新）。
  + 407 - Proxy Authentication Required 要求进行代理身份验证，类似于401，表示客户必须先经过代理服务器的授权。（新）
  + 408 - Request Timeout 在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。（新）
  + 409 - Conflict 通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。（新）
  + 410 - Gone 所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。（新）
  + 411 - Length Required 服务器不能处理请求，除非客户发送一个Content-Length头。（新）
  + 412 - Precondition Failed 请求头中指定的一些前提条件失败（新）。
  + 413 – Request Entity Too Large 目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头（新）。
  + 414 - Request URI Too Long URI太长（新）。
  + 415 – 不支持的媒体类型。
  + 416 – Requested Range Not Satisfiable 服务器不能满足客户在请求中指定的Range头。（新）
  + 417 – 执行失败。
  + 423 – 锁定的错误。

+ 5** - 服务器错误：服务器由于遇到错误而不能完成该请求。
  + 500 - Internal Server Error 服务器遇到了意料不到的情况，不能完成客户的请求。
    + 500.12 - 应用程序正忙于在 Web 服务器上重新启动。
    + 500.13 - Web 服务器太忙。
    + 500.15 - 不允许直接请求 Global.asa。
    + 500.16 – UNC 授权凭据不正确。这个错误代码为 IIS 6.0 所专用。
    + 500.18 – URL 授权存储不能打开。这个错误代码为 IIS 6.0 所专用。
    + 500.100 - 内部 ASP 错误。
  + 501 - Not Implemented 服务器不支持实现请求所需要的功能，页眉值指定了未实现的配置。例如，客户发出了一个服务器不支持的PUT请求。
  + 502 - Bad Gateway 服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答。 亦说Web 服务器用作网关或代理服务器时收到了无效响应。
    + 502.1 - CGI 应用程序超时。
    + 502.2 - CGI 应用程序出错。
  + 503 - Service Unavailable 服务不可用，服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个 Retry-After头。这个错误代码为 IIS 6.0 所专用。
  + 504 - Gateway Timeout 网关超时，由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答。（新） 。
  + 505 - HTTP Version Not Supported 服务器不支持请求中所指明的HTTP版本。（新）。