在设计系统时,要因场景,时间而异,一个系统也不是一下子就能设计得非常完美,在具有有限资源得情况下,一定是先解决当下最核心得问题,预测并发现未来可能出现得问题,一步步解决最痛点的问题;

设计开发系统,是一个不断迭代的过程,在迭代中发现问题并修复问题,这是一个持续的过程;

**一个好的设计要做到,解决现有需求和问题,把控实现和进度风险,预测和规划未来,不要过度设计,从迭代中演进和完善;**

>在设计系统时,多思考`墨菲定律`:
+ 任何事都没有表面看起来那么简单
+ 所有的事都会比你预计的时间长
+ 可能出错的事总会出错
+ 如果你担心某种情况发生,那么它就更有可能发生


>在系统划分时,思考`康威定律`:
+ 系统架构是公司组织架构的反映
+ 应该按照业务闭环进行系统拆分或组织架构划分,实现闭环,高内聚,低耦合,减少沟通成本
+ 如果沟通出现问题,那么就应该考虑进行系统和组织架构的调整
+ 在合适时机进行系统拆分,不要一开始就把系统或服务拆得非常细,虽然闭环,但是每个人维护的系统多,维护成本高;

## `高并发原则`

+ `无状态` : 应用无状态,配置文件有状态;

+ `拆分` : 在系统设计初期,是做一个而全的系统还是按功能模块是拆分系统,需要根据环境进行权衡;
  + `系统维度` : 按照系统功能,业务拆分,比如商品系统,购物车,结算,订单系统等;
  + `功能维度` : 对一个系统进行功能再拆分;
  + `读写维度` : 根据读写比例特征进行拆分;
  + `AOP维度` : 根据访问特征,按照`AOP`进行拆分;
  + `模块维度` : 按照基础或者代码维护特征进行拆分;

+ `服务化`
  + `进程内服务` --> `单机远程服务` --> `集群手动注册服务` --> `自动注册和发现服务` --> `服务的分组,隔离,路由` --> `服务治理如限流,黑白名单`

+ `消息队列` : 用来解耦一些不需要同步调用的服务或者订阅一些自己系统关心的变化;
  + `服务解耦(一对多消费)`
  + `异步处理`
  + `流量削峰,缓冲`
  + 需要注意处理生产消息失败,以及消息重复接收时的场景:
    + 不能容忍生产失败的业务场景,要做好后续数据处理工作,如持久化,增加日志,报警;
    + 在业务层面进行防重处理;

1. `大流量缓冲`

在电商大促时,系统流量会高于正常流量的几倍甚至几十倍,此时就要进行一些特殊的设计来保证系统平稳度过这段时期:
+ **`一般都是牺牲强一致性,而保证最终一致性即可`**

>**`扣减库存`** : 直接在`Redis`中扣减,然后记录下扣减日志,通过`Worker`同步到`DB`;

>**`交易订单系统`** : 
+ 结算服务调用订单接单服务,将订单存储到订单`Redis`和订单队列表;
+ 订单队列表,可以按照需求水平扩展多个表,通过队列缓冲表提升接单能力;
+ 通过同步`Worker`同步到订单中心表;
  + 假设用户支付了订单,订单状态机会驱动状态变更;
  + 若订单队列表的订单还没有同步到订单中心表,状态机要根据实际情况进行重试;
+ 如果用户查看单个订单详情,可以直接从订单`Redis`中查到;
+ 如果查询订单列表,则需要考虑订单`Redis`和列表的合并;
+ 同步`Worker`在设计时,需要考虑并发处理和重复处理的问题;

2. `数据校对`

在使用了消息异步机制的场景下,可能存在消息的丢失,需要考虑进行数据校对和修正来保证数据的一致性和完整性.
+ 可以通过`Worker`定期去扫描原始表,通过对业务数据进行校对,有问题的要进行补偿,扫描周期根据实际场景进行定义;

+ `数据异构`
  + 例如订单分库分表一般按照订单ID进行划分,如果要查询某个用户的订单列表,则需要聚合多个表的数据后才能返回,导致订单表的读性能很低;需要对订单表进行异构,异构一套用户订单表,按照用户`ID`进行分库分表;
  + 还需要考虑对历史订单数据进行归档处理,以提升服务的性能和稳定性;
+ `数据闭环` : 把使用到的数据进行异构存储,形成数据闭环;
  + `数据异构` : 通过如`MQ`机制接收数据变更,然后原子化存储到合适的存储引擎,如`Redis`或持久化`KV`存储;
  + `数据聚合` : 数据异构的目的是把数据从多个数据源拿过来的,数据聚合的目的是把这些数据做个聚合,这样前端就可以一个调用拿到所有数据,此步骤一般存储到`KV`存储中;
  + `前端展示` : 前端通过一次或少量几次调用拿到所需要的数据

  **数据闭环和数据异构其实是一个概念,目的都是实现数据的自我控制,当其他系统出问题时不影响自己的系统,或者自己出问题时不影响其他系统.一般通过消息队列来实现数据分发;**


+ `缓存银弹` : 缓存对于读服务来说可谓抗流量的银弹:
  + `客户端`
    + 使用浏览器缓存
      + 设置请求的过期时间,如对响应头`Expires`,`Cache-control`进行控制.
      + 适用于对实时性不太敏感的数据;
    + 客户端应用缓存 
      + 把APP需要访问的一些素材(`如js/css/image`)提前下发到客户端进行缓存;
  + `客户端网络`
    + 代理服务器开启缓存 
  + `广域网`
    + 使用代理服务器(含`CDN`) 
      + 有些页面,活动页,图片等服务可以考虑将页面,活动页,图片推送到离用户最近的`CDN`节点,让用户能在离他最近的节点找到想要的数据;
    + 使用镜像服务器
    + 使用`P2P`技术
  + `源站及源站网络`
    + 使用接入层提供的缓存机制 : 使用如`Nginx`搭建一层接入层
      + `URL重写` : 将`URL`按照指定的顺序或者格式重写,去除随机数
      + `一致性哈希` : 按照指定的参数做一致性`Hash`,从而保证相同数据落到一台服务器上;
      + `proxy_cache` : 使用内存级,SSD级代理缓存来缓存内容;
      + `proxy_cache_lock` : 使用`lock`机制,将多个回源合并为一个,以减少回源量,并设置相应的`lock`超时时间;
      + `shared_dict` : 如果架构使用了`nginx + lua`实现,则可以考虑使用`lua shared_dict`进行cache,最大的好处就是`reload`缓存不会丢失;
    + 使用应用层提供的缓存机制
    + 使用分布式缓存
    + 静态化,伪静态化
    + 使用服务器操作系统提供的缓存机制

+ `并发化`


## `高可用原则`

+ `降级` 
  + 开关集中化管理:通过推送机制把开关推送到各个应用
  + 可降级的多级读服务:比如服务调用降级为只读本地缓存,只读分布式缓存,只读默认降级数据;
  + 开关前置化:如架构是`Nginx->Tomcat`,可以将开关前置到`Nginx`接入层,在`Nginx`层做开关,请求流量回源后端应用或者只是一小部分流量回源;
  + 业务降级:当高并发流量来袭,可以把一些同步调用改成异步调用优先处理高优先级数据或特殊特征的数据,合理分配进入系统的流量,以保障系统可用;

