在我们的系统中,不是所有的处理都必须实时处理,不是所有的请求都必须实时反馈结果给用户,不是所有的请求都必须`100%`一次性处理成功,不知道那个系统依赖"我"来实现其业务处理,保证最终一致性,不需要强一致性;

>缺点:
+ 是否需要保证消息处理的有序性及如何保证?
+ 是否能重复消费及如何保证重复消费的幂等性?

>优点:
+ 异步处理 
+ 系统解耦
+ 数据同步
+ 流量削峰
+ 扩展性
+ 缓冲

## `缓冲队列`

典型的如`Log4j`日志缓冲区,当使用log4j记录日志时,可以配置字节缓冲区,字节缓冲区满时,会立即同步到磁盘.
+ `Log4j`是使用`BufferedWriter`实现的.
  + 此模式不是异步写,在缓冲区满的时候还是会阻塞主线程;
  + 如果需要异步模式,则可以使用`AsyncAppender`,然后通过`bufferSize`控制日志事件缓冲区大小;

**`在电商进行大促时,此时的系统流量会高于平常流量的几倍甚至几十倍,此时应进行一些特殊的设计来保证系统的平稳度过这段时期.而解决的手段很多,一般牺牲业务的强一致性,保证最终一致性即可.`**


>**`使用缓冲队列应对突发流量时,并不能使处理速度变快,而是使处理速度变平滑,从而不会因瞬间压力太大而压垮应用.`**
+ 通过缓冲区队列可以实现批量处理,异步处理和平滑流量;

## `任务队列`

使用`任务队列`可以将一些不需要与主线程同步执行的任务扔到任务队列进行异步处理.
+ 常见是`线程池任务队列(默认为LinkedBlockingQueue)`和`Disruptor任务队列(RingBuffer)`
+ `JDK1.7`提供了`ExecutorService`的新实现`ForkJoinPool`,其提供的`Work-stealing`机制,可以更好地提升并发效率;

>**`通过任务队列可以实现异步处理/任务分解/聚合处理;`**

## `消息队列`

使用`消息队列`存储各业务数据,其他系统根据需要订阅即可.**常见的订阅模式使:`点对点`/`发布订阅`;**

一般情况下,我们会在应用系统中采用双写模式,同时写`DB`和`MQ`,然后异构系统可以订阅`MQ`进行业务处理．
+ 因为在双写模式下没有事务保证,所以会出现数据不一致的情况,如果对一致性要求没那么严格,则这种模式是没问题的,而且在实际应用中这种模式也非常多.


>+ 如果在事务中发`MQ`,会存在事务回滚,但是`MQ`发送成功了,则需要消息消费者进行幂等处理.
+ 如果事务提交慢,但是`MQ`已经发出去了，则此时根据`MQ`信息再去获取数据库数据可能不是最新的.
+ 如果`MQ`发送慢，则会导致事务无法快速提交，造成数据库阻塞．

**可以采用订阅数据库日志机制来实现数据库变更捕获,这样生产系统只需要单写`DB`,然后通过如`Canal`订阅数据库`binlog`实现数据库数据变更捕获,然后业务端订阅`Canal`进行业务处理.(`这种方式可以保证一致性`)**

>**`通过消息队列可以实现异步处理/系统解耦和数据异构.`**

## `请求队列`

`请求队列`是指类似在`Web`环境下对用户请求排队,从而进行一些特殊控制:`流量控制/请求分级/请求隔离`.

+ 如将请求按照功能划分到不同的队列,从而使得不同的队列出现问题后相互不影响.
+ 如对请求分级,一些重要的请求可以优先处理(发展到一定程度应将功能物理分离).
+ 如在接近服务器瓶颈时需要考虑限流,最简单的限流是丢弃处理不了的请求.

## `数据总线队列`

一般消息队列中的消息都是业务维度的简单数据,如业务键或业务状态.例如在商品信息变更场景中,当`SKU`信息变更了,只下发了一个`SKU ID`,订阅者需要再查一遍商品系统来获取最新的变更数据,进行鼓路商品信息缓存同步.
**`所以使用现有的消息队列方式很难只进行变更部分的推送并保证数据的有序性.`**

而此种场景比较适合使用`数据总线队列`实现:
+ 数据库变更后需要同步数据到缓存;
+ 需要将一个机房的数据同步到另一个机房;

>**`使用数据总线队列的好处是,可以保证数据的有序性.`**

阿里的`otter`是基于`Canal`的一款分布式数据库同步系统.如果想实时进行多机房/多数据库数据增量同步,则可以使用`otter`.如果需要全量离线数据同步,则可以使用`kettle`;

