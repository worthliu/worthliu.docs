`限流`的目的是通过对并发访问或请求进行限速或者一个时间窗口内的请求进行限速来保护系统,一旦达到限制速率则可以拒绝服务,排队或等待,降级;
+ 限制总并发数(如:数据库连接池,线程池)
+ 限制瞬间并发数(如:`Nginx`的`limit-conn`模块,用来限制瞬间并发连接数)
+ 限制时间窗口内的平均速率(如:`Guava`的`RateLimiter`,`Nginx`的`limit_req`模块,用来限制每秒的平均速率)
+ 限制远程接口调用速率
+ 限制`MQ`消费速率

## `限流算法`

### `令牌桶算法`

令牌桶算法,是一个存放固定容量令牌的桶,按照固定速率往桶里添加令牌;

>算法描述:
+ 假设限制`2r/s`,则按照500毫秒的固定速率往桶总添加令牌;
+ 桶中最多存放`b`个令牌,当桶满时,新添加的令牌被丢弃或拒绝;
+ 当一个`n`个字节大小的数据包到达,将从桶中删除`n`个令牌,接着数据包被发送到网络上;
+ 如果桶中的令牌不足`n`个,则不会删除令牌,且该数据包将被限流(要么丢弃,要么在缓冲区等待)


### `漏桶算法`

漏桶作为计量工具(`The Leaky Bucket Algorithm as a Meter`)时,可以用于流量整形和流量控制;

>算法描述:
+ 一个固定容量的漏桶,按照常量固定速率流出水滴
+ 如果桶是空的,则不需流出水滴
+ 可以以任意速率流入水滴到漏桶
+ 如果流入水滴超出了桶的容量,则流入的水滴溢出了(被丢弃),而漏桶容量是不变的


两种算法的比较:
+ `令牌桶`是**按照固定速率往桶中添加令牌**,请求是否被处理需要看桶中令牌是否足够,`当令牌数减为零时,则拒绝新的请求`;
+ `漏桶`是**按照常量固定速率流出请求**,流入请求速率任意,`当流入的请求数累积到漏桶容量时,则新流入的请求被拒绝`;
+ `令牌桶`限制的是**平均流入速率(允许突发请求,只要有令牌就可以处理),并允许一定程度的突发流量**;
+ `漏桶`限制的是**常量流出速率(即流出速率是一个固定常量值)**,从而平滑突发流入速率;


**`计数器`来进行限流,主要用来限制总并发数.只要全局请求数或者一定时间段的总请求数达到设定阈值,则进行限流;**