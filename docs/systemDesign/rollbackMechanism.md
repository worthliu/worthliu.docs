回滚是指当程序或数据出错时,将程序或数据恢复到最近的一个正确版本的行为;

## `事务回滚`

在执行数据库`SQL`时,如果检测到事务提交冲突,那么事务中所有已执行的`SQL`要进行回滚,目的是防止数据库出现数据不一致.

对于单库事务回滚直接使用相关`SQL`即可.

如果涉及分布式数据,则要考虑使用分布式事务,最常见的如两阶段提交,三阶段提交协议.这种方式实现事务回滚难度较低,但是对性能影响比较大,因为在大多数场景中需要的是`最终一致性`,而不是`强一致性`;

可以考虑如`事务表`,`消息队列`,`补偿机制(执行/回滚)`,`TCC模式(预占/确认/取消)`,`Sagas模式(拆分事务+补偿机制)`等实现最终一致性.

例如提交订单请求,可能需要横跨多个服务:`结算服务,优惠券服务,库存服务,订单服务`;
+ 当订单出错后,需要把之前扣减的优惠券和库存回滚.
  + 当保存订单出错时,JVM实例挂掉了,那么之前扣减的优惠券和库存就没有回滚,这种情况可以考虑在本地记录事务日志,当`JVM`实例重启后,分析事务日志重新回滚;
  + 也可以记录事务日志表,或者通过补偿机制,定期扫描优惠券和库存使用表,回滚没有关联的订单或者已取消的订单记录;
+ 下单后一直没有支付,要定期扫描订单表,然后取消订单并回滚优惠券和库存;

## `代码库回滚`

在开发项目时,一定要将代码维护到代码仓库,从而进行版本管理.
+ `SVN`,集中版本控制系统;
+ `Git`,分布式版本控制系统;

## `部署版本回滚`

代码测试完成后,接下来就要进行系统的部署,在部署系统时,要考虑当代码逻辑出现错误后如何快速恢复;

+ `部署版本化` : 每次部署时,应该将上一版本的包记录到部署系统中,在发布时应该采用全量发布,避免增量发布;

+ `小版本增量发布`

+ `大版本灰度发布` : 在页面改版/添加新的功能时需要进行灰度发布,一般情况时两个版本并行跑一段时间;功能验证成功后或者新版版本效果不错时,再全量发布;
  + 可以通过类似带有版本号的`URL`来区分新版本和老版本;

+ `架构升级并发布` : 架构升级后,上线时不清楚新版本是否功能正常,因此,新老版本部署集群会同时存在一段时间.然后,等所有流量迁移到新版版本集群后,老版本集群就可以下线了;

## `数据版本回滚`

有些特定行业业务数据中的商品/价格数据需要进行版本化处理,
+ 为了审计需要
+ 为了出现问题时能及时回滚

>设计版本化数据结构时:
+ 全量版本化,指即使只变更了其中一个字段也将整体记录进行历史版本化,保存的数据量比较多,但是回滚方便.
+ 增量版本化,指只保存变化的字段,保存的数据量较少,但是回滚起来很麻烦,需要回溯;

**在设计消息队列时,重要业务会对消息进行副本处理,以便万一业务逻辑出现问题能进行历史数据回滚,从而修复问题;**

## `静态资源版本回滚`

因为静态资源一般放在CDN上,所以缓存时间设置得比较长,这样若发布得版本有问题,则需要清理CDN缓存,也需要清理浏览器缓存,而且因为存在版本覆盖得问题,所以即使覆盖了也不一定保证操作正确;

>+ 发布新的静态资源到源服务器
+ 清理CDN缓存,从而可以回源服务器获取最新得静态资源
+ 在新的URL上添加随机数并清理浏览器缓存

