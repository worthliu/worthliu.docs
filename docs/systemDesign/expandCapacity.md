对于系统设计,理想读取情况下应支持线性扩容和弹性扩容,即在系统瓶颈时,只需要增加机器就可以解决系统瓶颈,如降低延迟提升吞吐量,从而实现扩容需求;

如果你想扩容,则支持水平/垂直伸缩是前提.在进行拆分时,一定要清楚知道自己的目的是什么,拆分后带来的问题如何解决,拆分后如果没有得到任何收益就不要为了拆而拆,即不要过度拆分,要适合自己的业务;

## `单体应用垂直扩容`

如果能通过硬件快速解决,而且成本不高,应该首先通过硬件扩容来解决问题.
+ `硬件扩容` : 升级现有服务器(如`CPU核数`,内存大小)
+ `磁盘扩容`

## `单体应用水平扩容`

`单体应用水平扩容`是通过部署更多的镜像来实现的.

如,原来通过一个系统实例对外提供服务,通过扩容到更多实例后,用户访问时不可能提供多个`域名/IP`入口,应该提供统一入口,此时就需要负载均衡机制来实现;
+ 如果用户会话数据分散在应用系统,就需要在负载均衡器开启会话黏滞特性;
+ 如果数据库的瓶颈是读造成的,则此时可以通过主从数据库架构将读的流量分散到更多的从服务器上,写数据时写到主数据库,读数据时读取从数据库;

## `应用拆分`

当单体应用发展到一定地步时,会按照业务进行拆分;
+ 拆分时要进行业务代码解耦,将功能分离到不同系统上;
+ 拆分后系统之间是物理隔离的,方法调用需要改成远程方法调用;
+ 系统增多,系统服务化;
+ 系统流量增大,需要继续拆分业务系统;


## `数据库拆分`

随着流量的增加,数据库的压力也会随之而来,一般会伴随着应用拆分进行数据库拆分;
+ 按照业务维度进行垂直拆分,目的是**`解决多个表之间的IO竞争/单机容量问题`**等;
  + `跨库join`可以考虑通过如全局表,ES搜索等异构数据机制来实现.
+ 流量的增加,进行读写分离来解决,将读写进行拆分;

+ 流量和数据量的增加,单库单表会遇到`容量和磁盘/带宽IO`瓶颈,此时就需要分库,分表或者分库分表; 
  + 分库分表是一种水平数据拆分,会按照如`ID/用户/时间`等维度进行数据拆分,拆分算法可以是`取模/哈希/区间或者使用数据路由表`等;
    + 对于`跨库/跨表join和排序分页`,可以对所有表进行扫描然后做聚合,或者生成全局表,进行查询维度的数据异构;
    + 分布式事务可以考虑`事务表`,`补偿机制(执行/回滚)`,`TCC模式(预占/确认/取消)`,`Sagas模式(拆分事务+补偿机制)`等;
    + 业务应**`尽量设计为最终一致性,而不是强一致性`**;

+ 对于一些特殊数据,可以考虑`NoSQL`
  + 部署多个`Redis`实例,通过`Twemproxy`并使用一致性哈希算法进行分片,先通过`HaProxy`进行`Twemproxy`的负载均衡,然后通过内网域名进行访问;

+ 如购物车数据,是用户维度数据,完全可以全量存储到`KV`存储中,如使用`Redis`进行存储.为了数据的安全性,可以考虑双写架构
  + 最简单的办法是**`在多个集群间通过主从来解决`**,不过主从切换比较麻烦,当主从断开后需要全量更新时恢复较慢;
  + 程序双写,实现逻辑比较简单且切换方便.
    + 程序双写可以是程序同步双写,写失败其中一个就都失败.
    + 这种方式性能差,不适合多机房同步写,也不适合同步写多个集群;
  + 异步双写:
    + 首先把变更发布到数据总线(如通过`MQ`实现);
    + 然后订阅数据总线变更,异步写其他集群;
    + 这种方式的优点是性能好,缺点是异步同步有一定的时延,数据一致性差一些,应考虑使用一致性哈希把用户调度到同一个集群,防止用户刷新多次看到不一样的数据;

## `数据库分库分表示例`

数据库分库分表就会涉及如何写入和读取数据的问题,应用开发人员主要关心:
+ 是否需要在应用层做改造来支持分库分表,即是在应用层进行支持,还是通过中间件层呢?
+ 如果需要应用层做支持,那么分库分表的算法是什么?
+ 分库分表后,join是否支持,排序分页是否支持,事务是否支持?

### `应用层还是中间层`

分库分表可以在应用层实现,也可以在中间件层实现,**`中间件层实现的好处是对应用透明,应用就像查单库单表一样去查询中间件层`**:
+ 使用数据库中间件层还有一个好处是可以支持多种编程语言,而不受限于特定的语言;
+ 使用数据库中间件层可以减少应用的总数据库连接数,从而避免因为应用过多导致数据库链接不够用.
+ **`缺点是除了维护中间件外,还要考虑中间件的HA/负载均衡等,增加了部署和维护的困难,因此还要看当前阶段有没有必要使用中间件和有没有人维护该中间件;`**

>开源的数据库中间件:
+ 基于`MySQL-Proxy`开发的奇虎360的`Atlas`;
  + 只支持分表或分库(`sharding版本`)/读写分离等,不支持跨库分表,`sharding`版本不支持跨库操作(跨库事务/跨库join等)
+ 阿里的`Cobar`;
  + 支持分库不支持分表,不支持跨库join/分页/排序等;
+ 基于`Cobar`开发的`Mycat`
  + 支持分库分表/读写分离/跨库弱事务支持,对跨库join等有限支持(内存聚合);


>应用层可以在`JDBC`驱动层/`DAO`框架层,如`iBatis/Mybatis/Hibernate/JPA`上完成:
+ 如当当的`sharding-jdbc`是`JDBC`驱动层实现;
+ 阿里的`cobar-client`是基于`DAO`框架`iBatis`实现;

**应用系统直接在应用代码总耦合了分库分表逻辑,然后通过如`iBatis/JDBC`直接分库分表实现;**

### `分库分表策略`

**`分库分表策略是指按照什么算法或规则进行存储,它会影响数据的写入和读取,比如按照订单ID分库分表,那么就很难按照客户维度进行订单查询.因此,在进行分库分表时需要慎重考虑使用什么策略.`**

+ `取模`
  + 优点是数据热点分散
  + 缺点是按照非主键维度进行查询时需要跨库/跨表查询,扩容给需要建立新集群并进行数据迁移.

+ `分区`
  + 可按照时间分区/范围分区进行分库分表:
    + 时间分区规则如一个月一个表,一年一个库;
    + 范围分区规则如`0~2000万`一个表,`2000~4000万`一个表;
  + 如果分区规则很复杂,则可以有一个路由表来存储分库分表规则;
  + **缺点是存在热点,但是易于水平扩展,能避免数据迁移**;


### `使用sharding-jdbc分库分表`

在数据库设计起初一般都是单库单表设计,随着数据量的增长将带来存储容量和写/读性能瓶颈问题.
+ 如果是容量问题,则可以通过分库到多台机器解决
+ 引起写/读问题的主要原因是记录太多(几千万到一亿),列数太多,索引太多,查询太复杂等引发单表出现性能问题;

`sharding-JDBC`的分库分表算法是独立的,即分库可以使用一套规则,分表可以使用一套规则;且其支持柔性事务(`最大努力送达`);

>柔性事务
+ 最大努力送达是事务失败后通过最大努力反复尝试送达操作实现,是在假定数据库操作一定可以成功的前提下进行的,保证数据最终的一致性.
  + 适用场景是幂等性操作;
  + `同步送达`不需要`ZooKeeper`和`elastic-job`,内置在柔性事务模块中.
  + `异步送达`是对柔性事务的最终补偿,不能和应用程序部署在一起,需要额外地通过`elastic-job`实现.

### `使用sharding-jdbc读写分离`

随着数据库读访问量的增长,主库不能承受更多的读访问,此时,可以通过给主库挂从库,然后把读访问分流到从库来减少主库的压力.

**`sharding-jdbc通过简单的配置就可以支持读写分离.`**

使用读写分离对于刚刚写入的数据,要立即读取是读不到.因为`MySQL`默认使用异步复制,复制是有一定延迟的.**`因此要想在写完后立即读数据,可以通过Hint机制强制读取主库;`**

`Sharding-JDBC`读写分离为了最大限度避免由于同步延迟而产生强制读取主库的场景,在更新方面做了优化,**`在一个请求线程中,只要存在对数据库的更新操作,则在此操作之后的任何对数据库的访问都会自动通过路由达到主库.`**
+ 在写后读的场景中不需要使用`HintManager`;
+ 在读场景下,需要强制读主库时,才使用`HintManager`强制通过路由到达主库;

## `数据异构`

分库分表后将带来很多问题,如跨库join,非分库分表维度的条件查询/分页排序等.

可以通过内存聚合,数据异构(全局表/ES搜索/异构表)等来实现.`数据异构`主要按照不同查询维度建立表结构;

在数据量和访问量双高时使用数据异构是非常有效的,但增加了架构的复杂度,异构时可以通过订阅`MQ`或者`binlog`并解析实现;

