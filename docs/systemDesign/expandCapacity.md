对于系统设计,理想读取情况下应支持线性扩容和弹性扩容,即在系统瓶颈时,只需要增加机器就可以解决系统瓶颈,如降低延迟提升吞吐量,从而实现扩容需求;

如果你想扩容,则支持水平/垂直伸缩是前提.在进行拆分时,一定要清楚知道自己的目的是什么,拆分后带来的问题如何解决,拆分后如果没有得到任何收益就不要为了拆而拆,即不要过度拆分,要适合自己的业务;

## `单体应用垂直扩容`

如果能通过硬件快速解决,而且成本不高,应该首先通过硬件扩容来解决问题.
+ `硬件扩容` : 升级现有服务器(如`CPU核数`,内存大小)
+ `磁盘扩容`

## `单体应用水平扩容`

`单体应用水平扩容`是通过部署更多的镜像来实现的.

如,原来通过一个系统实例对外提供服务,通过扩容到更多实例后,用户访问时不可能提供多个`域名/IP`入口,应该提供统一入口,此时就需要负载均衡机制来实现;
+ 如果用户会话数据分散在应用系统,就需要在负载均衡器开启会话黏滞特性;
+ 如果数据库的瓶颈是读造成的,则此时可以通过主从数据库架构将读的流量分散到更多的从服务器上,写数据时写到主数据库,读数据时读取从数据库;

## `应用拆分`

当单体应用发展到一定地步时,会按照业务进行拆分;
+ 拆分时要进行业务代码解耦,将功能分离到不同系统上;
+ 拆分后系统之间是物理隔离的,方法调用需要改成远程方法调用;
+ 系统增多,系统服务化;
+ 系统流量增大,需要继续拆分业务系统;


## `数据库拆分`

随着流量的增加,数据库的压力也会随之而来,一般会伴随着应用拆分进行数据库拆分;
+ 按照业务维度进行垂直拆分,目的是**`解决多个表之间的IO竞争/单机容量问题`**等;
  + `跨库join`可以考虑通过如全局表,ES搜索等异构数据机制来实现.
+ 流量的增加,进行读写分离来解决,将读写进行拆分;
+ 流量和数据量的增加,单库单表会遇到`容量和磁盘/带宽IO`瓶颈,此时就需要分库,分表或者分库分表; 
  + 分库分表是一种水平数据拆分,会按照如`ID/用户/时间`等维度进行数据拆分,拆分算法可以是`取模/哈希/区间或者使用数据路由表`等;
    + 对于`跨库/跨表join和排序分页`,可以对所有表进行扫描然后做聚合,或者生成全局表,进行查询维度的数据异构;
    + 分布式事务可以考虑事务表,补偿机制(执行/回滚),TCC模式(预占/确认/取消),Sagas模式(拆分事务+补偿机制)等;
    + 业务应尽量设计为最终一致性,而不是强一致性;
