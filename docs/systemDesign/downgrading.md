当访问量剧增/服务出现问题(如响应时间长或不响应)或非核心服务影响到核心流程的性能时,仍然需要保证服务还是可用的,即使是有损服务.系统可以根据一些关键数据进行自动降级,也可以配置开关实现人工降级.

**`降级的最终目的是保证核心服务可用,即使是有损的.`**

## `降级预案`

在进行降级之前要对系统进行梳理,看看系统是不是可以丢卒保帅,从而梳理出哪些必须誓死保护,哪些可降级;

+ `一般` : 有些服务偶尔因为网络抖动或者服务正在上线而超时，可以自动降级；
+ `警告` : 有些服务在一段时间内成功率有波动，可以自动降级或人工降级，并发送警告；
+ `错误` : 可用率低于`90%`,或者数据库连接池用完了,或者访问量突然猛增到系统能承受的最大阈值,此时,可以根据情况自动地降级或者人工降级;
+ `严重错误` : 因为特殊原因数据出现错误,需要紧急人工降级;

## `自动开关降级`

自动降级是根据系统负载/资源使用情况/`SLA`等指标进行降级;

+ `超时降级` : 当访问的数据库/`HTTP`服务/远程调用响应慢或者长时间响应慢,且该服务不是核心服务的话,可以在超时后自动降级.
  + 需要配置好超时时间和超时重试次数及机制
+ `统计失败次数降级` : 当失败调用次数达到一定阈值自动降级(熔断器) ,然后通过异步线程去探测服务是否恢复了,恢复则取消降级;
+ `故障降级` : 要调用的远程服务挂掉了(网络故障/`DNS`故障/`HTTP`服务返回错误的状态码/`RPC`服务抛出异常),则可以直接降级;
  + 降级后的处理方案:
    + 默认值
    + 兜底数据
    + 缓存
+ `限流降级` : 当达到限流阈值时,后续请求会被降级;
  + 排队页面
  + 无货
  + 错误页

## `人工开关降级`

开关可以存放到配置文件/数据库/`Redis/Zookeeper`.如果不是存放在本地,则可以定期同步开关数据.然后,通过判断某个`key`的值来决定是否降级;

## `读服务降级`

对于读服务降级一般采用的策略有:`暂时切换读(降级到读缓存,降级到走静态化)`,`暂时屏蔽读(屏蔽读入口,屏蔽某个读服务)`;

`页面降级`,`页面片段降级`,`页面异步请求降级都是读服务降级`,目的是丢卒保帅;

## `写服务降级`

写服务在大多数场景下是不可降级的,但是可以通过一些迂回战术来解决问题;
+ 将同步操作转换为异步操作
+ 限制写的量/比例

**秒杀库存:`扣减Redis库存`,`正常同步扣减DB库存`,`性能扛不住时降级为写扣减DB库存消息到本机`,`然后本机通过异步进行DB库存扣减来实现最终一致性`.**

## `多级降级`

缓存是离用户越近越搞笑,而降级是离用户越近越对系统保护得好.因为业务的复杂性导致越到后端`QPS/TPS`越低;

+ `页面JS降级开关` : 主要控制页面功能的降级,在页面中,通过JS脚本部署功能降级开关,在适当时机开启/关闭开关;
+ `接入层降级开关` : 主要控制请求入口的降级,请求进入后,会首先进入接入层,在接入层可以配置功能降级开关,可以根据实际情况进行自动/人工降级;
+ `应用层降级开关` : 主要控制业务的降级,在应用中配置相应的功能开关,根据实际业务情况进行自动/人工降级;

## `配置中心`

我们需要通过配置方式来动态开启/关闭降级开关,在应用时,首先要封装一套应用层`API`方便业务逻辑使用.

对于开关数据的存储,如果涉及的服务器/系统较少,则初期可以考虑使用配置文件进行配置.如果涉及的服务/系统较多,则应该使用配置中心进行配置.实现时要做到不需要修改代码,不需要重启应用即可动态配置开关;

