## JVM内存结构

`JVM`内存布局规定了`Java`在运行过程中内存申请,分配,管理的策略,保证了`JVM`的高效稳定运行;

`JVM`启动时将内存划分成几个特定数据区域,每个数据区域都有特定内存管理方法：

![jvmmemorystructure](/images/jvmmemorystructure.png)

![jvm](/images/jvm.png)


>1. `Heap`(堆区)
 + `Heap`时`OOM故障`的最主要的发源地,存储着几乎所有的实例对象,堆由垃圾收集器自动回收,**堆区由各子线程共享使用**.
 + 堆的内存空间既可以固定大小,也可以在运行是动态地调整,通过`-Xms`,`-Xmx`设置堆大小容量;
   + **在通常情况下,服务器在运行过程中,堆空间不断地扩容与回缩,势必形成不必要的系统压力**,所以在线上生产环境中,`JVM`的`Xms`,`Xmx`设置成一样大小,避免在`GC`后调整堆大小时带来的额外压力;
 + 堆分成两大块:`新生代`和`老年代`:
  + 对象产生之初在新生代,步入暮年时进入老年代,但是老年代也接纳在新生代无法容纳的超大对象;
  + `新生代` = `1个Eden区` + `2个Surviror区`
    + 绝大部分对象在`Eden区`生成,当`Eden区`装填满的时候,会触发`Young Garbage Collection`,即`YGC`.
    + 垃圾回收的时候,在`Eden区`实现清除策略,没有被引用的对象则直接回收.依然存活的对象会被移送到`Survior区`,这个区真是名副其实的存在.
    + `Survivor区`分为S0和S1两块内存空间,然后将当前正在使用的空间完全清除,交换两块空间的使用状态.
    + 如果`YGC`要移送的对象大于`Survivor`区容量的上限,则直接移交给老年代;
    + `-XX:MaxTenuringThreshold`参数能配置计数器的值到达某个阈值的时候,对象从新生代晋升老年代.
  + 如果`Survivor`区无法放下,或者超大对象的阈值超过上限,则尝试在老年代中进行分配;
  + 如果老年代也无法放下,则会触发`Full Garbage Collection`,即FGC.
  + 出错时的堆内信息对解决问题非常有帮助,`JVM`设置运行参数`-XX:+HeapDumpOnOutOfMemoryError`,让`JVM`遇到`OOM异常`时能输出堆内信息;

>2. `Metaspace`(元空间)
  + `JDK8`版本中,元空间的前身`Perm区`已经被淘汰.
  + `JDK7`及之前的版本中,只有`Hotspot`才有`Perm区`,译为永久代,**它在启动时间固定大小,很难进行调优,并且`FGC`时会移动类元信息;**
  + 在某些场景下,如果动态加载类过多,容易产生`Perm区`的`OOM`;
  + `元空间`,区别于`永久代`,**在本地内存中分配**;
    + `JDK8`中,`Perm区`中所有内容中**字符串常量**移至至**堆内存**;
    + 其他内容包括`类元信息`,`字段`,`静态属性`,`方法`,`常量`等都移动至元空间类;

>3. `JVM Stack`(虚拟机栈)
  + `JVM`是基于栈结构的运行环境.(**栈结构移植性更好,可控性更强**)
  + **`JVM`中的虚拟机栈是描述`Java方法`执行的内存区域,它是线程私有的.**
  + 栈中的元素用于支持虚拟机进行方法调用,每个方法从开始调用到执行完成的过程,就是栈帧从入栈到出栈的过程.
  + 在活动线程中,只有位于栈顶的帧才是有效的,称为**当前栈帧**;
  + `StackOverflowError`表示请求的栈溢出,导致内存耗尽,通常出现在递归方法中;
  + **栈帧**:`局部变量表`,`操作栈`,`动态连接`,`方法返回地址`等
    + `局部变量表`是存放方法参数和局部变量的区域;
    + `操作栈`是一个初始状态为空的桶式结构栈.
      + 在方法执行过程中,会有各种指令往栈中写入和提取信息.
      + `JVM`的执行引擎是基于栈的执行引擎,其中的栈指的就是操作栈;
    + `动态链接`,**每个栈帧中包含一个在常量池中对当前方法的引用,目的是支持方法调用过程的`动态链接`;**
    + `方法返回地址`


>4. `Native Method Stacks`(本地方法栈)
  + 在`JVM`内存布局中,也是线程对象私有的;
  + 本地方法栈为`Native`方法服务.线程开始调用本地方法时,会进入一个不再受`JVM`约束的世界;
  + 本地方法可以通过`JNI(Java Native Interface)`来访问虚拟机运行时的数据区,甚至可以调用寄存器,具有和`JVM`相同的能力和权限;

>5. `Program Counter Register`(程序计数寄存器)
  + 在`程序计数寄存器`(Program Counter Register,PC)中,`Register`的命名源于`CPU`的寄存器,`CPU`只有把数据装载到寄存器才能运行;
  + **每个线程在创建后,都会产生自己的程序计数器和栈帧,程序计数器用来存放执行指令的偏移量和行号指示器等,线程执行或恢复都要依赖程序计数器.**
  + 程序计数器在各个线程之间互不影响,此区域也不会发生内存溢出异常;

在`JMM`中我们可以知道`JVM`工作的单元是线程，每个线程都有自己工作内存，且不同线程之间共享主内存。而主内存`JVM`中主要代表是`Java堆内存`；

## 对象实例化

Java是面向对象的静态强类型语言,声明并创建对象的代码很常见,根据某个类声明一个引用变量指向被创建的对象,并使用此引用变量操作该对象.

```
Object obj = new Object();
```

```
stack=2, locals=2, args_size=1
         0: new           #2                  // class java/lang/Object
         3: dup
         4: invokespecial #1                  // Method java/lang/Object."<init>":()V
         7: astore_1
         8: return
      LineNumberTable:
        line 12: 0
        line 13: 8
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       9     0  args   [Ljava/lang/String;
            8       1     1 object   Ljava/lang/Object;

```
**字节码指令查看,对象实例化过程**

> `new` : 
+ 如果找不到`Class`对象,则进行类加载.
+ 加载成功后,则在堆中分配内存,从`Object`开始到本类路径上的所有属性值都要分配内存.
+ 分配完毕之后,进行零值初始化.
+ 在分配过程中,注意引用是占据存储空间的,它是一个变量,占用4个子节;
+ 这个指令完毕后,将指向实例对象的引用变量压入虚拟机栈顶;

>`dup`:
+ 在栈顶复制该引用变量,这时的栈顶有两个指向堆内实例对象的引用变量;
+ 如果`<init>`方法有参数,还需要把参数压入操作栈中.

> `invokespecial` : 
+ 调用对象实例方法,通过栈顶的引用变量调用`<init>`方法;
+ **`<clinit>`是类初始化时执行的方法,而`<init>`是对象初始化时执行的方法;**

**从执行步骤的角度来分析:**

>+ `确认类元信息是否存在`.
  + 当JVM接收到`new`指令时,首先在`metaspace`类检查需要创建的类元信息是否存在.
  + 若不存在,在双亲委派模式下,使用当前类加载器以`ClassLoader`+包名+类名为key进行查找对应的`.class`文件.
  + 如果没有找到`.class`文件,则抛出`ClassNotFoundException`异常;
  + 如果找到,则进行类加载,并生成对应的`Class`类对象;

>+ `分配对象内存`
  + 首先计算对象占用空间大小,如果实例成员变量时引用变量,仅分配引用变量空间即可,`即4个字节大小`;
  + 接着在堆中划分一块内存给新对象;
  + 在分配内存空间时,需要进行同步操作,比如采用`CAS(compare And Swap)`失败重试,区域加锁等方式保证分配操作的原子性;

>+ `设定默认值`
  + 成员变量值都需要设定为默认值,即各种不同形式的零值;

>+ `设置对象头`
  + 设置新对象的哈希码,GC信息,锁信息,对象所属的类元信息等;

>+ `执行init方法`
  + 初始化成员变量,执行实例化代码块,调用类的构造方法,并把堆内对象的首地址赋值给引用变量;


>如上述代码出现在方法体中，
+ `Object obj` 这部分语义将会反映到**`Java栈的本地变量表`**中，作为一个`reference`类型数据出现。
+ `new Object()` 这部分的语义将会反映到`Java堆`中，形成一块存储了`Object`类型所有实例数据值(`Instance Data，对象中各个实例字段的数据`)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存长度是不固定的。

**(由于`reference类型`在Java虚拟机规范里面`只规定了一个指向对象的引用`，**并没有定义这个引用应该通过那种方式去定位，以及访问到Java堆中的对象的具体位置**，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针)**

### 访问方式

>1. **使用句柄**：Java堆中将会划出一块内存来作为句柄池，`reference`中存储的就是对象的句柄地址，而句柄中包含了**对象实例数据和类型数据各自具体地址信息**； 

![HandleAccess](/images/HandleAccess.png)

>2. **直接指针访问**：Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，**`reference`中直接存储的就是`对象地址`**；

![PointerAccess](/images/PointerAccess.png)

>这两种对象的访问方式各有优势：
1. **句柄访问**，reference中存储的是稳定的句柄地址，在对象被移动**（垃圾收集时移动对象是非常普遍的行为）**时只会改变句柄中的实例数据指针，而`reference`本身不需要被修改；
2. **指针访问方式**，速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，这种开销的节省非常可观；

**`HotSpot`而言使用的是指针访问方式。**