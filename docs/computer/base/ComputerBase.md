# 计算机基础

计算机就是晶体管、电路板组装起来的电子设备，无论是图形图像的渲染、网络远程共享，还是大数据计算，归根结底都是`0`与`1`的信号处理。由于信息存储和逻辑计算的元数据，只能是`0`和`1`；

因此，计算机世界的基础是`0`、`1`组成的二进制；

而计算机最主要的功能是计算，那么二进制之间`加减`是如何计算的呢？

在计算机世界,负数与正数表示是一致，只是负数采用最右边一位二进制位`1`表示负数;

那么二进制数字加减全部转为**二进制的补码加法运算；**

>而负数参与是通过负数二进制表示的补码进行的，且符号位也参与运算，溢出位抛弃；

**(负数的补码是反码加1的结果，正数的补码是本身)**


Example:

```
   00100011(35)   补码
 + 11011011(-37)  补码
 _________________
   11111110       补码

负数:最左1位表示负,右7位值取反+1：-(0000001 + 1) = -2

```

>+ 8个bit组成一个单位，称为一个字节，即1个Byte，简写为B；
+ `1024个Byte`，简写为`KB`；
+ `1024个KB`，简写为`MB`；
+ `1024个MB`，简写为`GB`；
+ `1024个GB`，简写为`TB`；
+ `1024个TB`，简写为`PB`；
+ `1024个PB`，简写为`EB`；
+ `1024个EB`，简写为`ZB`；
+ `1024个ZB`，简写为`YB`；

### 位移运算

向右移动`1`位近似表示`除以2`，十进制的奇数转化为二进制数后，在向右移时，`最右边的1`将被直接抹去，说明向右移对于奇数并非完全相当于除以2；

在左移`<<`与右移`>>`两种运算中，符号位参与移动，除负数往右移动，`高位补1`之外，其他情况均在`空位处0`；

>Example： 带符号位位移运算

正数/负数|向左移`<<`1位|向右移`>>`1位|
--|--|--|
正数（35的补码`00100011`）|`01000110 = 2^6 + 2^2 + 2^1 = 70`|`00010001 = 2^4 + 2^0 = 17`（近似除以2）|
负数（-35的补码`11011101`）|`10111010 = 1(1000101 + 1) = -70`|`11101110 = 1(0010001 + 1) = -18`|
正数（99的补码`01100011`）|`11000110 = -58`|`00110001 = 49`|
负数（-99的补码`10011101`）|`00111010 = 58`|`11001110 = -50`|


`>>>`无符号向右移动（**不存在`<<<`无符号向左移动**），当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值是1。

>**无符号即藐视符号位，符号位失去特权，必须像其他平常的数字位一起向右移动，高位直接补0，根本不关心是正数还是负数。**

>Example：无符号位移运算

正数/负数|向右移`>>>`1位|向右移`>>>`2位|向右移`>>>`3位|
--|--|--|--|
正数（35的补码`0010 0011`）| `00010001 = 17` | `00001000 = 8` | `00000100 = 4` |
负数（-35的补码`1101 1101`）| `01101110 = 110` | `00110111 = 55` | `00011011 = 27` |


>为什么负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32位）和长整型（64位）的数上，假如在整型数上移动的位数是32位，无论是否带符号以及移动方向，均为本身。

因为移动的位数是一个`mod 32`的结果，即`35 >> 1`与`35 >> 33` 是一样的结果。如果长整型，`mod 64`，即`35 << 1`与`35<<65`的结果是一样的。

负数在符号的往右移动63位时，除最右边为1外，左边均为0，达到最小值1，如果`>>>64`，则为其原数值本身；


>位运算其他操作：
+ 按位取反（~）
+ 按位与（&），典型场景是获取网段值，IP地址与掩码`255.255.255.0`进行按位与运算得到高24位，即为当前IP的网段。（逻辑与`&&`，有短路功能）
+ 按位或（|）
+ 按位异或（^）

### 浮点数

计算机定义了两种小数，定点数和浮点数。其中，定点数的小数点位置是固定的，在确定字长的系统中一旦指定小数点的位置后，它的整数部分和小数部分也随之确定。

二者相互独立表示，互不干扰。由于小数点位置是固定的，所以定点数能够表示的范围非常有限；

浮点数，表示就是如何用二进制数表示符号、指数和有效数字；（业界流行的浮点数标准是IEEE754，该标准规定了4种浮点数类型，单精度、双精度、延伸单精度、延伸双精度）

精度|字节数|正数取值范围|负数取值范围|
--|--|--|--|
单精度|4|`1.4e-45至3.4e+38`|`-3.4e+38至-1.4e-45`|
双精度|8|`4.9e-324至1.798e+308`|`-1.798e+308至-4.9e-324`|

---

以单精度为例，4个字节，总共32位：
>1. 符号位，在最高位二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数；
2. 阶码位，在符号位右侧分配8位用来存储指数，IEEE754标准规定阶码位存储的是指数对应的`移码`，而不是指数的原码或补码;
  + 移码是将一个真值在数轴上正向平移一个偏移值之后得到的，即`[X]移=x + 2^(n-1)`(n为x的二进制位数，含符号位)；
  + 移码可以直观地反映两个真值的大小，即移码大的真值也大；(无需比较正负值)
3. 尾数位，最右侧分配连续的23位用来存储有效数字，IEEE754标准规定尾数以原码表示。
  + 正指数和有效数字的最大值决定了32位存储空间能够表示浮点数的十进制最大值。
  + 指数最大值为`2^127 = 1.7 * 10^38`，有效数字部分最大值是二进制的1.111..1（小数点后23个1），是一个无限接近于2的数字；

>**为什么偏移值为2^(n-1)-1而不是2^(n-1)呢？**
+ 因为8个二进制位能表示指数的取值范围为`[-128，127]`，现在将指数编程移码表示，即将区间`[-128，127]`正向平移到正数域，区间里的每个数都需要加上128，从而得到阶码范围为`[0，255]`。由于计算机全为0或全为1两种情况被当作特殊值处理（全0认为是机器零，全1被认为是无穷大），去掉这两个特殊值，价码的取值范围编程了`[1，254]`。
+ 如果偏移量不变仍为128的话，则根据换算关系公式`[X]阶=x+128`得到的指数的范围编程[-127，126]，指数最大只能取到126，显然会缩小浮点数能表示的取值范围。
+ 所以IEEE754标准规定单精度的阶码偏移量为`2^(n-1)-1`，这样能表示的指数范围为[-126，127]，指数最大值能取到127；
  

#### 加减运算

在数学中，进行两个小数的加减运算是，首先要将小数点对齐，然后同位数进行加减运算。对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。当小数点对齐后，再将有效数字按照正常的数进行加减运算；

>+ `零值检测`，检查参加运算的两个数中是否存在为0的数（0在浮点数是一种规定，即阶码与尾数全为0），因为浮点数运算过程比较复杂，如果其中一个数为0，可以直接得出结果；
+ `对阶操作`，通过比较阶码的大小判断小数点位置是否对齐。当阶码不相等时表示当前两个浮点数的小数点位置没有对齐，则需要通过移动尾数改变阶码的大小使二者最终相等；尾数向右移动1位，则阶码值加1，反之减1。`在移动尾数时，部分二进制位将会被移出，但向左移会使高位被移出，对结果造成的误差更大`；
+ `尾数求和`，当对阶完成后，直接按位相加即可完成求和（如果是负数则需要先转换成补码再进行运算）
+ `结果规格化`，如果运算结果仍然满足规格化形式,则无须处理,否则需要通过尾数位向左或向右移动调整达到规格化形式。
+ `结果舍入`，在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃，从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后在根据保护位进行舍入处理；


#### 浮点数使用

在使用浮点数时推荐使用双精度，使用单精度由于表示区间的限制，计算结果会出现微小的误差；

在要求绝对精确表示的业务场景下，比如金融业行业的货币表示，推荐使用整型存储其最小单元的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储；

在数据库中保存小数时，推荐使用decimal类型，禁止使用float类型和double类型。

### 字符集与乱码

>如何将0和1表示成我们看到的文字呢？

从26个英文字母说起，大小写共52个，加上10个数字达到62个，考虑到还有特殊字符（如：`！@#￥%……&*｛｝|`等）和不可见的控制字符，必然超过64个，“64”即2的6次方，使用刚才的0与1组合，至少是7组连续的信号量！

计算机在诞生之初对于存储和传输介质实在没有什么信心，所以预留了一个bit用于奇偶校验，这就是1个Byte（字节）由8个bit组成的来历，也就是`ASCII码`；

汉字的字符集，由于ASCII码先入为主，必须在它基础上继续编码，而一个字节只能表示128个字符，所以采用双字节进行编码，因此早期使用的标准`GB2312`收录了`6763`个常用汉字；

GBK (k是拼音kuo的首字母，是扩展的意思)支持繁体，兼容GB2312。GB18030是国家标准，在技术上是GBK的超集并与之兼容。

>1994年正式公布Unicode，为每种语言中的每个字符都设定了唯一编码，以满足跨语言的交流，分为编码方式和实现方式。
+ 编码格式：UTF-8、UTF-16、UTF-32，UTF（Unicode Transformation Format）即Unicode字符集转换格式，可以理解为对Unicode的压缩方式；


### CPU与内存

CPU（Central Processing Unit）是一块超大规模的集成电路板，是计算机的核心部件，承载着计算机的主要运算和控制功能，是计算机指令的最终解释模块和执行模块；

硬件包括基板、核心、针脚，基板用来固定核心和针脚，针脚通过基板上的基座连接电路信号，CPU核心的工艺极度精密，达到10纳米级别；


>CPU内部结构，由控制器、运算器和寄存器组成;
+ 控制器，由控制单元、指令译码器、指令寄存器组成；
  + 控制单元是CPU的大脑，由时序控制和指令控制等组成；
  + 指令译码器是在控制单元的协调下完成指令读取、分析并交由运算器执行等操作；
  + 指令寄存器是存储指令即，当前流行的指令集包括X86、SSE、MMX等；
+ 运算器，核心是算术逻辑运算单元，即ALU；能够执行算术运算或逻辑运算等各种命令，运算单元会从寄存器中提取或存储数据。
+ 寄存器，最著名的寄存器是CPU的高速缓存L1、L2，缓存容量是在组装计算机时必问的两个CPU性能问题之一。


### TCP/IP

#### 网络协议

TCP/IP(Transmission Control Protocol/Internet Protocol)，传输控制协议/因特网互联协议，这个协议族群里还有HTTP、HTTPS、FTP、SMTP、UDP、ARP、PPP、IEEE802.x等。

![TCP/IP](/images/TCPIP.png)

>+ 链路层：链路层以字节为单位把0与1进行分组，定义数据帧，写入源和目标机器的物理地址、数据、校验位来传输数据；
+ 网络层：根据IP定义网络地址，区分网段。子网内根据地址解析协议（ARP）进行MAC寻址，子网外进行路由转发数据包，这个数据包即IP数据包；
+ 传输层：数据包通过网络层发送到目标计算机后，应用程序在传输层定义逻辑端口，确认身份后，将数据包交给应用程序，实现端口到端口间通信。
  + UDP：UDP只是IP数据包上增加端口等部分信息，是面向无连接的，是不可靠传输，多用于视屏通信、电话会议等（即使少一帧数据也无妨）
  + TCP：TCP是面向连接的，所谓面向连接，是一种端到端间通过失败重传机制建立的可靠数据传输方式，给人感觉是有一条固定的通路承载着数据的可靠传输；
+ 应用层：传输层的数据到达应用程序时，以某种统一规定的协议格式解读数据；

>程序在发送消息时，应用按既定的协议打包数据，随后由`传输层`加上双方的`端口号`，由`网络层`加上双方的`IP地址`，有`链路层`加上双方的`MAC地址`，并将`数据`拆分成`数据帧`，经过多个路由器和网关后，到达目标机器。简而言之，就是按`“端口->IP地址->MAC地址”`，这样的路径进行数据的封装和发送，解包的时候反过来操作即可；


#### IP协议
IP协议是面向无连接、无状态的没有额外的机制保证发送的包是否有序到达；

IP协议，首先规定出IP地址格式，该地址相当与在逻辑意义上进行了网段的划分，给每台计算机额外设置了一个唯一的详细地址。

>既然链路层可以通过唯一的MAC地址找到机器，为什么还需要通过唯一的IP地址再来标识？
+ 简单而言，在世界范围内，不可能通过广播的方式，从数以千万的计算机里找到目标MAC地址的计算机而不超时；

IP地址属于网络层，主要功能在WLAN内进行路由寻址，选择最佳路由。

![IP](/images/IPProtocol.png)

协议结构比较简单，其中数据包的生存时间，即TTL(Time To Live)，该字段表示IP报文被路由器丢弃之前可经过的最多的路由总数。

**TTL初始值由源主机设置后，数据包在传输过程中每经过一个路由器TTL值则减1，当该字段为0时，数据包被丢弃，并发送ICMP报文通知源主机，以防止源主机无休止地发送报文。**

ICMP（Internet Control Message Protocol），它是检测传输网络是否通畅、主机是否可达、路由是否可用等网络运行状态的协议。

ICMP虽然并不传输用户数据，但是对评估网络健康状态非常重要，经常使用的ping、tracert命令就是基于ICMP检测网络状态的有力工具。

#### TCP建立连接

传输控制协议（Transmission Control Protocol，TCP），是一种面向连接、确保数据在端到端间可靠传输的协议。

面向连接是指在发送数居前，需要先建立一条虚拟的链路，然后让数据在这个链路上“流动”完成传输。为了确保数据的可靠传输，不仅需要对发出的每一个字节进行编号确认，校验每一个数据包的有效性，在出现超时情况时进行重传，还需要通过实现滑动窗口和拥塞控制等机制，避免网络状况恶化而最终影响数据传输的极端情形；


>三次握手建立连接步骤：
+ A机器发出一个数据包并将SYN置1，表示希望建立连接。这个包中的序列号假设是X；
+ B机器收到A机器发过来的数据包后，通过SYN得到这是一个建立连接的请求，于是发送一个响应包并将SYN和ACK标记都置1。假设这个包中的序列号是y，而确认序列号必须是x+1，表示收到了A发过来的SYN。在TCP中，SYN被当作数据部分的一个字节；
+ A收到B的响应包后需进行确认，确认包中将ACK置1，并将确认序列号设置为y+1，表示收到了来自B的SYN；

