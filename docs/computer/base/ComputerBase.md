# 计算机基础

计算机就是晶体管、电路板组装起来的电子设备，无论是图形图像的渲染、网络远程共享，还是大数据计算，归根结底都是`0`与`1`的信号处理。由于信息存储和逻辑计算的元数据，只能是`0`和`1`；

因此，计算机世界的基础是`0`、`1`组成的二进制；而计算机最主要的功能是计算，那么二进制之间`加减`是如何计算的呢？

在计算机世界,负数与正数表示是一致，只是负数采用最右边一位二进制位`1`表示负数;那么二进制数字加减全部转为**二进制的补码加法运算；**

而负数参与是通过负数二进制表示的补码进行的，且符号位也参与运算，溢出位抛弃；

***(负数的补码是反码加1的结果，正数的补码是本身)***


Example:

```
   00100011(35)   补码
 + 11011011(-37)  补码
 _________________
   11111110       补码

负数:最左1位表示负,右7位值取反+1：-(0000001 + 1) = -2

```


>+ 8个bit组成一个单位，称为一个字节，即1个Byte，简写为B；
+ 1024个Byte，简写为KB；
+ 1024个KB，简写为MB；
+ 1024个MB，简写为GB；
+ 1024个GB，简写为TB；
+ 1024个TB，简写为PB；
+ 1024个PB，简写为EB；
+ 1024个EB，简写为ZB；
+ 1024个ZB，简写为YB；


### 位移运算

向右移动`1`位近似表示`除以2`，十进制的奇数转化为二进制数后，在向右移时，`最右边的1`将被直接抹去，说明向右移对于奇数并非完全相当于除以2；

在左移`<<`与右移`>>`两种运算中，符号位参与移动，除负数往右移动，`高位补1`之外，其他情况均在`空位处0`；

>Example： 带符号位位移运算

正数/负数|向左移`<<`1位|向右移`>>`1位|
--|--|--|
正数（35的补码`00100011`）|`01000110 = 2^6 + 2^2 + 2^1 = 70`|`00010001 = 2^4 + 2^0 = 17`（近似除以2）|
负数（-35的补码`11011101`）|`10111010 = 1(1000101 + 1) = -70`|`11101110 = 1(0010001 + 1) = -18`|
正数（99的补码`01100011`）|`11000110 = -58`|`00110001 = 49`|
负数（-99的补码`10011101`）|`00111010 = 58`|`11001110 = -50`|


`>>>`无符号向右移动（**不存在`<<<`无符号向左移动**），当向右移动时，正负数高位均补0，正数不断向右移动的最小值是0，而负数不断向右移动的最小值是1。

***无符号即藐视符号位，符号位失去特权，必须像其他平常的数字位一起向右移动，高位直接补0，根本不关心是正数还是负数。***

>Example：无符号位移运算

正数/负数|向右移`>>>`1位|向右移`>>>`2位|向右移`>>>`3位|
--|--|--|--|
正数（35的补码`0010 0011`）| `00010001 = 17` | `00001000 = 8` | `00000100 = 4` |
负数（-35的补码`1101 1101`）| `01101110 = 110` | `00110111 = 55` | `00011011 = 27` |


>为什么负数不断地无符号向右移动的最小值是1呢？

在实际编程中，位移运算仅作用于整型（32位）和长整型（64位）的数上，假如在整型数上移动的位数是32位，无论是否带符号以及移动方向，均为本身。

因为移动的位数是一个`mod 32`的结果，即`35 >> 1`与`35 >> 33` 是一样的结果。如果长整型，`mod 64`，即`35 << 1`与`35<<65`的结果是一样的。

负数在符号的往右移动63位时，除最右边为1外，左边均为0，达到最小值1，如果`>>>64`，则为其原数值本身；


>位运算其他操作：
+ 按位取反（~）
+ 按位与（&），典型场景是获取网段值，IP地址与掩码`255.255.255.0`进行按位与运算得到高24位，即为当前IP的网段。（逻辑与`&&`，有短路功能）
+ 按位或（|）
+ 按位异或（^）

### 浮点数

计算机定义了两种小数，定点数和浮点数。其中，定点数的小数点位置是固定的，在确定字长的系统中一旦指定小数点的位置后，它的整数部分和小数部分也随之确定。

二者相互独立表示，互不干扰。由于小数点位置是固定的，所以定点数能够表示的范围非常有限；

浮点数，表示就是如何用二进制数表示符号、指数和有效数字；（业界流行的浮点数标准是IEEE754，该标准规定了4种浮点数类型，单精度、双精度、延伸单精度、延伸双精度）

精度|字节数|正数取值范围|负数取值范围|
--|--|--|--|
单精度|4|`1.4e-45至3.4e+38`|`-3.4e+38至-1.4e-45`|
双精度|8|`4.9e-324至1.798e+308`|`-1.798e+308至-4.9e-324`|

---

以单精度为例，4个字节，总共32位：
>1. 符号位，在最高位二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数；
2. 阶码位，在符号位右侧分配8位用来存储指数，IEEE754标准规定阶码位存储的是指数对应的`移码`，而不是指数的原码或补码;
  + 移码是将一个真值在数轴上正向平移一个偏移值之后得到的，即`[X]移=x + 2^(n-1)`(n为x的二进制位数，含符号位)；
  + 移码可以直观地反映两个真值的大小，即移码大的真值也大；(无需比较正负值)
3. 尾数位，最右侧分配连续的23位用来存储有效数字，IEEE754标准规定尾数以原码表示。
  + 正指数和有效数字的最大值决定了32位存储空间能够表示浮点数的十进制最大值。
  + 指数最大值为`2^127 = 1.7 * 10^38`，有效数字部分最大值是二进制的1.111..1（小数点后23个1），是一个无限接近于2的数字；

>**为什么偏移值为2^(n-1)-1而不是2^(n-1)呢？**
+ 因为8个二进制位能表示指数的取值范围为`[-128，127]`，现在将指数编程移码表示，即将区间`[-128，127]`正向平移到正数域，区间里的每个数都需要加上128，从而得到阶码范围为`[0，255]`。由于计算机全为0或全为1两种情况被当作特殊值处理（全0认为是机器零，全1被认为是无穷大），去掉这两个特殊值，价码的取值范围编程了`[1，254]`。
+ 如果偏移量不变仍为128的话，则根据换算关系公式`[X]阶=x+128`得到的指数的范围编程[-127，126]，指数最大只能取到126，显然会缩小浮点数能表示的取值范围。
+ 所以IEEE754标准规定单精度的阶码偏移量为`2^(n-1)-1`，这样能表示的指数范围为[-126，127]，指数最大值能取到127；
  

#### 加减运算

在数学中，进行两个小数的加减运算是，首先要将小数点对齐，然后同位数进行加减运算。对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。当小数点对齐后，再将有效数字按照正常的数进行加减运算；

>+ 零值检测，检查参加运算的两个数中是否存在为0的数（0在浮点数是一种规定，即阶码与尾数全为0），因为浮点数运算过程比较复杂，如果其中一个数为0，可以直接得出结果；
+ 对阶操作，通过比较阶码的大小判断小数点位置是否对齐。当阶码不相等时表示当前两个浮点数的小数点位置没有对齐，则需要通过移动尾数改变阶码的大小使二者最终相等；尾数向右移动1位，则阶码值加1，反之减1。`在移动尾数时，部分二进制位将会被移出，但向左移会使高位被移出，对结果造成的误差更大`；
+ 尾数求和，当对阶完成后，直接按位相加即可完成求和（如果是负数则需要先转换成补码再进行运算）
+ 结果规格化，

