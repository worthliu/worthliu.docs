## 浮点数

计算机定义了两种小数，定点数和浮点数。其中，定点数的小数点位置是固定的，在确定字长的系统中一旦指定小数点的位置后，它的整数部分和小数部分也随之确定。

二者相互独立表示，互不干扰。由于小数点位置是固定的，所以定点数能够表示的范围非常有限；

浮点数，表示就是如何用二进制数表示符号、指数和有效数字；（业界流行的浮点数标准是IEEE754，该标准规定了4种浮点数类型，单精度、双精度、延伸单精度、延伸双精度）

精度|字节数|正数取值范围|负数取值范围|
--|--|--|--|
单精度|4|`1.4e-45至3.4e+38`|`-3.4e+38至-1.4e-45`|
双精度|8|`4.9e-324至1.798e+308`|`-1.798e+308至-4.9e-324`|

---

以单精度为例，4个字节，总共32位：
>1. 符号位，在最高位二进制位上分配1位表示浮点数的符号，0表示正数，1表示负数；
2. 阶码位，在符号位右侧分配8位用来存储指数，IEEE754标准规定阶码位存储的是指数对应的`移码`，而不是指数的原码或补码;
  + 移码是将一个真值在数轴上正向平移一个偏移值之后得到的，即`[X]移=x + 2^(n-1)`(n为x的二进制位数，含符号位)；
  + 移码可以直观地反映两个真值的大小，即移码大的真值也大；(无需比较正负值)
3. 尾数位，最右侧分配连续的23位用来存储有效数字，IEEE754标准规定尾数以原码表示。
  + 正指数和有效数字的最大值决定了32位存储空间能够表示浮点数的十进制最大值。
  + 指数最大值为`2^127 = 1.7 * 10^38`，有效数字部分最大值是二进制的1.111..1（小数点后23个1），是一个无限接近于2的数字；

>**为什么偏移值为2^(n-1)-1而不是2^(n-1)呢？**
+ 因为8个二进制位能表示指数的取值范围为`[-128，127]`，现在将指数编程移码表示，即将区间`[-128，127]`正向平移到正数域，区间里的每个数都需要加上128，从而得到阶码范围为`[0，255]`。由于计算机全为0或全为1两种情况被当作特殊值处理（全0认为是机器零，全1被认为是无穷大），去掉这两个特殊值，价码的取值范围编程了`[1，254]`。
+ 如果偏移量不变仍为128的话，则根据换算关系公式`[X]阶=x+128`得到的指数的范围编程[-127，126]，指数最大只能取到126，显然会缩小浮点数能表示的取值范围。
+ 所以IEEE754标准规定单精度的阶码偏移量为`2^(n-1)-1`，这样能表示的指数范围为[-126，127]，指数最大值能取到127；
  

### 加减运算

在数学中，进行两个小数的加减运算是，首先要将小数点对齐，然后同位数进行加减运算。对两个采用科学计数法表示的数做加减法运算时，为了让小数点对齐就需要确保指数一样。当小数点对齐后，再将有效数字按照正常的数进行加减运算；

>+ `零值检测`，检查参加运算的两个数中是否存在为0的数（0在浮点数是一种规定，即阶码与尾数全为0），因为浮点数运算过程比较复杂，如果其中一个数为0，可以直接得出结果；
+ `对阶操作`，通过比较阶码的大小判断小数点位置是否对齐。当阶码不相等时表示当前两个浮点数的小数点位置没有对齐，则需要通过移动尾数改变阶码的大小使二者最终相等；尾数向右移动1位，则阶码值加1，反之减1。`在移动尾数时，部分二进制位将会被移出，但向左移会使高位被移出，对结果造成的误差更大`；
+ `尾数求和`，当对阶完成后，直接按位相加即可完成求和（如果是负数则需要先转换成补码再进行运算）
+ `结果规格化`，如果运算结果仍然满足规格化形式,则无须处理,否则需要通过尾数位向左或向右移动调整达到规格化形式。
+ `结果舍入`，在对阶过程或右规时，尾数需要右移，最右端被移出的位会被丢弃，从而导致结果精度的损失。为了减少这种精度的损失，先将移出的这部分数据保存起来，称为保护位，等到规格化后在根据保护位进行舍入处理；


### 浮点数使用

在使用浮点数时推荐使用双精度，使用单精度由于表示区间的限制，计算结果会出现微小的误差；

在要求绝对精确表示的业务场景下，比如金融业行业的货币表示，推荐使用整型存储其最小单元的值，展示时可以转换成该货币的常用单位，比如人民币使用分存储，美元使用美分存储；

在数据库中保存小数时，推荐使用decimal类型，禁止使用float类型和double类型。