# 重排序

### 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。
>重排序三种类型：
1. **编译器优化的重排序**，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. **指令级并行的重排序**，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
3. **内存系统的重排序**，由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行；

*(对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序；对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序)*

![javareorder](/images/javareorder.png)

**指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性**

## 数据依赖性

如果两个操作访问同一个变量,且这两个操作中有一个为写操作,此时这个两个操作之间就存在数据依赖性.

>数据依赖:
1. 写后读,写一个变量之后,再读这个位置;
2. 写后写,写一个变量之后,再写这个变量;
3. 读后写,读一个变量之后,再写这个变量;

***(编译器和处理器可能会对操作做重排序,在重排序时,会遵守数据依赖性,不会改变存在数据依赖关系的两个操作的执行顺序)***

## as-if-serial语义

>as-if-serial语义的意思指:不管怎么重排序(编译器和处理器为了提高并行度),(单线程)程序的执行结果不能被改变.编译器,runtime和处理器都必须遵守as-if-serial语义.
***(该语义把单线程程序保护了起来,创造一个幻觉:单线程程序时按程序的顺序来执行的)***

## 程序顺序规则

```
double pi = 3.14;
double r = 1.0;
double area = pi * r * r;
```

>依据happens-before的程序顺序规则,上述代码存在三个happens-before关系:
1. A happens-before B;
2. B happens-before C;
3. A happens-before C;

这里A happens-before B,但实际执行时B却可以排在A之前执行;如果A happens-before B,JMM并不要求A一定要在B之前执行．JMM仅仅要求前一个操作（执行结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前．

>软件技术和硬件技术有一个共同的目标:在不改变程序执行结果的前提下,尽可能的开发并行度.(JMM同样遵从这个目标)


## 重排序对多线程的影响

>在单线程程序中，对存在控制依赖的操作重排序，不会改变执行结果；但在多线程程序中，对存在控制依赖的操作重排序，可能会改变程序的执行结果；

