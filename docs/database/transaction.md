事务就是一组原子性的SQL查询,或者说一个独立的工作单元.

## 事务的`ACID`

**事务具有四个特征：`原子性(Atomicity)`、`一致性(Consistency)`、`隔离性(Isolation)`和`持续性(Durability)`。**

这四个特性简称为 ACID 特性。
     
>1. `原子性`:**事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做**
2. `一致性`:**事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。**
  + **因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。**
  + **如果数据库运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。**
3. `隔离性`:**一个事务的执行不能其它事务干扰。**
  + **即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。**
4. `持续性`:**也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。**

### `InnoDB`中如何保证`ACID`

+ 原子性,通过`InnoDB`事务控制
+ 一致性
  + 使用`InnoDB`存储引擎双写缓冲(`doublewrite buffer`);
    + `InnoDB`使用一种文件缓存计数称为双写缓冲.在写数据文件之前,`InnoDB`首先将数据写到一个连续内存区域缓冲区;只有在写入和刷新双重写入缓冲区之后，InnoDB才会将页面数据写到数据文件中的适当位置。
    + 如果操作系统、存储子系统或mysqld进程在页面写入过程中崩溃，InnoDB稍后可以在崩溃恢复期间从doublewrite缓冲区中找到该页面数据的完整副本。
  + 故障修复;
    + 在`MySQL`崩溃后重启时开启清理活动;对于`Innodb`数据表,不完整事务的恢复将使用`redo log`中的数据进行重做.崩溃前提交但尚未写入数据文件的恢复从`doublewrite`缓冲区里读取数据重新构建.
    + 当数据库正常关闭时,清理活动在关闭期间启动;
    + 在正常操作期间,事务提交的数据在写入磁盘数据文件之前先存放到`change buffer`一段时间.在保持数据文件实时性和缓存数据的时间需要做出权衡,这关系到日常数据操作性能开销和关闭崩溃恢复所带来的花费时间长短;
+ 隔离性
  + 事务
  + 隔离级别
  + `InnoDB`锁
+ 持久性
  + 双写缓冲
  + 在存储设备中写入缓冲
  + 运行`MySQL`的操作系统支持`fsync()`调用
  + 不掉电保护运行`MySQL`服务器和存储`MySQL`数据的设备电源
  + 备份策略,如果频率和类型,备份保留期


### `redo log`

崩溃恢复期间使用的一种基于磁盘的数据结构，用于纠正不完整事务所写的数据。
在正常操作期间，它对更改InnoDB表数据的请求进行标记，标记的数据来源于SQL语句或NoSQL接口直接调用底层API产生的。数据库崩溃后重启时自动重做未完成数据文件写入操作;


`redo log`物理上表现为一组文件,类似命名为`ib_logfile0 `,`ib_logfile1`;`redo log`文件数据是标记数据操作受到影响的记录;在`MySQL 5.6.3`中，对`redo log`的最大大小的原始`4GB`限制提高到了`512GB`。


`redo log`由`innodb_log_file_size`、`innodb_log_group_home_dir`和`innodb_log_files_in_group`配置控制文件大小,文件位置。重做日志操作的性能也受到日志缓冲区的影响，日志缓冲区由`innodb_log_buffer_size`配置选项控制。

### `undo log`

用于备份**当前活动事务正在修改地数据**的存储区域;如果另外一个事务需要查询原始数据时(一致性读操作的一部分),当前未修改地数据可以从这块区域中恢复;

`undo log`被分割成两个单独的部分，即插入撤消缓冲区和更新撤消缓冲区。

`undo`是逻辑日志,因此只是将数据库逻辑地恢复到原来的样子。

所有修改都被逻辑地取消了,但是数据结构和页本身在回滚之后可能大不相同。

这是因为在多用户并发系统中,可能会有数十、数百甚至数千个并发事务。数据库的主要任务就是协调对数据记录的并发访问。比如,一个事务在修改当前一个页中某几条记录,同时还有别的事务在对同一个页中另几条记录进行修改。因此,不能将一个页回滚到事务开始的样子,因为这样会影响其他事务正在进行的工作。

## 隔离级别

在SQL标准中定义了四种隔离级别,每一种级别都规定了一个事务中所做的修改,哪些在事务内和事务间是可见的,哪些是不可见的.

低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

>+ `Read Uncommitted（读取未提交内容）`
  + 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
  + 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。
  + `读取未提交的数据，也被称之为脏读（Dirty Read）`
+ `Read Committed（读取提交内容）`
  + 这是大多数数据库系统的默认隔离级别（但不是`MySQL默认的`）。
  + 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
  + 这种隔离级别也支持所谓的`不可重复读（Nonrepeatable Read）`，因为同一事务的其他实例在该实例处理其间可能会有新的`commit`，所以同一`select`可能返回不同结果。
+ `Repeatable Read（可重读）`
  + 这是**`MySQL的默认事务隔离级别`**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
  + 不过理论上，这会导致另一个棘手的问题：`幻读 （Phantom Read）`;
    + 简单的说，**`幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行`**;
    + `InnoDB`和`Falcon`存储引擎通过多版本并发控制（`MVCC，Multiversion Concurrency Control`）机制解决了该问题。
+ `Serializable（可串行化）`
  + 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
  + 简言之，它是在每个读的数据行上加上共享锁。
  + 在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。


数据库操作过程中,事务之间可能产生问题如下,由此衍生出数据库的四类隔离级别:

>+ `脏读(Drity Read)`
  + 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个`RollBack`了操作，则后一个事务所读取的数据就会是不正确的。
+ `不可重复读(Non-repeatable read)`
  + 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
+ `幻读(Phantom Read)`
  + 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

## 死锁

死锁是指两个或者多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.

+ 当多个事务试图以不同的顺序锁定资源时,就可能会产生死锁;
+ 多个事务同时锁定同一个资源时,也会产生死锁;

为了解决这种问题,数据库系统实现了各种死锁检测和死锁超时机制.

+ 越复杂的系统,比如`InnoDB`存储引擎,越能检测到死锁的循环依赖,并立即返回一个错误.

这种解决方式很有效,否则死锁会导致出现非常慢的查询.

+ 另一种解决方式,就是当查询的时间达到锁等待超时的设定后放弃锁请求;

>`InnoDB`目前处理死锁的方法是:
+ 将持有最少行级排他锁的事务进行回滚;

锁的行为和顺序是和存储引擎相关的.以同样的顺序执行语句,有些存储引擎会产生死锁,有些则不会.

**死锁的产生有双重原因:有些是因为真正的数据冲突,这种情况通常很难避免,但有些则完全是由于存储引擎的实现方式导致的;**

>**`死锁发生以后,只有部分或者完全回滚其中一个事务,才能打破死锁;`**

## 事务日志

事务日志可以帮助提高事务的效率.使用事务日志,存储引擎在修改表的数据时只需要修改其内存拷贝,再把该修改行为记录到持久在硬盘上的事务日志中,而不用每次都将修改的数据本身持久到磁盘.

>+ 事务日志采用的是追加的方式,因此写日志的操作是磁盘上一小块区域内的顺序`IO`,而不像随机`IO`需要在磁盘的多个地方移动磁头,所以采用事务日志的方式相对来说要快得多.
+ 事务日志持久以后,内存中被修改的数据在后台可以慢慢地刷回到磁盘.

**如果数据的修改已经记录到事务日志并持久化,但数据本身还没有写回磁盘,此时系统崩溃,存储引擎在重启时能够自动恢复这部分修改的数据.`具体的恢复方式则视存储引擎而定;`**

## `MySQL`中的事务

`MySQL`提供了两种事务型的存储引擎:`InnoDB`和`NDB Cluster`.另外还有一些第三方存储引擎也支持事务,比较知名的包括`XtraDB`和`PBXT`.

**`MySQL默认采用自动提交(AUTOCOMMIT)模式.`**如果不是显式地开始一个事务,则每个查询都被当作一个事务执行提交操作.

**修改`AUTOCOMMIT`对非事务型的表,比如`MyISAM`或者内存表,不会有任何影响.对这类表来说,没有`COMMIT`或者`ROLLBACK`的概念,也可以说是相当于一直处于`AUTOCOMMIT`启用的模式;**


>+ `MySQL`可以通过执行`SET TRANSACTION ISOLATION LEVEL`命令来设置隔离级别;
  + 新的隔离级别会在下一个事务开始的时候生效;
+ 在配置文件中设置整个数据库的隔离级别;

### 在事务中混合使用存储引擎

`MySQL`服务器层不管理事务,事务是由下层的存储引擎实现的.所以在同一个事务中,使用多种存储引擎是不可靠的;

>+ 如果在事务中混合使用了`事务型`和`非事务型`的表(例如`InnoDB`和`MyISAM`表),在正常提交的情况下不会有什么问题;
+ 如果该事务需要回滚,非事务型的表上的变更就无法撤销,这会导致数据库处于不一致的状态,这种情况很难修复,事务的最终结果将无法确定.
  
**为每张表选择合适的存储引擎非常重要;**

