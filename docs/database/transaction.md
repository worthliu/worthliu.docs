事务就是一组原子性的SQL查询,或者说一个独立的工作单元.

## 事务的`ACID`

**事务具有四个特征：`原子性(Atomicity)`、`一致性(Consistency)`、`隔离性(Isolation)`和`持续性(Durability)`。**

这四个特性简称为 ACID 特性。
     
>1. `原子性`:**事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做**
2. `一致性`:**事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。**
  + **因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。**
  + **如果数据库运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。**
3. `隔离性`:**一个事务的执行不能其它事务干扰。**
  + **即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。**
4. `持续性`:**也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。**

### `InnoDB`中如何保证`ACID`

+ 原子性,通过`InnoDB`事务控制
+ 一致性
  + 使用`InnoDB`存储引擎双写缓冲(`doublewrite buffer`);`InnoDB`使用一种文件缓存计数称为双写缓冲.在写数据文件之前,`InnoDB`首先将数据写到一个连续内存区域缓冲区;只有在写入和刷新双重写入缓冲区之后，InnoDB才会将页面数据写到数据文件中的适当位置。如果操作系统、存储子系统或mysqld进程在页面写入过程中崩溃，InnoDB稍后可以在崩溃恢复期间从doublewrite缓冲区中找到该页面数据的完整副本。
  + 故障修复
   
+ 隔离性


## 隔离级别

在SQL标准中定义了四种隔离级别,每一种级别都规定了一个事务中所做的修改,哪些在事务内和事务间是可见的,哪些是不可见的.

低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

>+ `Read Uncommitted（读取未提交内容）`
  + 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。
  + 本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。
  + `读取未提交的数据，也被称之为脏读（Dirty Read）`
+ `Read Committed（读取提交内容）`
  + 这是大多数数据库系统的默认隔离级别（但不是`MySQL默认的`）。
  + 它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。
  + 这种隔离级别也支持所谓的`不可重复读（Nonrepeatable Read）`，因为同一事务的其他实例在该实例处理其间可能会有新的`commit`，所以同一`select`可能返回不同结果。
+ `Repeatable Read（可重读）`
  + 这是**`MySQL的默认事务隔离级别`**，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。
  + 不过理论上，这会导致另一个棘手的问题：`幻读 （Phantom Read）`;
    + 简单的说，**`幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行`**;
    + `InnoDB`和`Falcon`存储引擎通过多版本并发控制（`MVCC，Multiversion Concurrency Control`）机制解决了该问题。
+ `Serializable（可串行化）`
  + 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。
  + 简言之，它是在每个读的数据行上加上共享锁。
  + 在这个级别，可能导致大量的超时现象和锁竞争。

这四种隔离级别采取不同的锁类型来实现，若读取的是同一个数据的话，就容易发生问题。


数据库操作过程中,事务之间可能产生问题如下,由此衍生出数据库的四类隔离级别:

>+ `脏读(Drity Read)`
  + 某个事务已更新一份数据，另一个事务在此时读取了同一份数据，由于某些原因，前一个`RollBack`了操作，则后一个事务所读取的数据就会是不正确的。
+ `不可重复读(Non-repeatable read)`
  + 在一个事务的两次查询之中数据不一致，这可能是两次查询过程中间插入了一个事务更新的原有的数据。
+ `幻读(Phantom Read)`
  + 在一个事务的两次查询中数据笔数不一致，例如有一个事务查询了几列(Row)数据，而另一个事务却在此时插入了新的几列数据，先前的事务在接下来的查询中，就会发现有几列数据是它先前所没有的。

## 死锁

死锁是指两个或者多个事务在同一资源上相互占用,并请求锁定对方占用的资源,从而导致恶性循环的现象.

+ 当多个事务试图以不同的顺序锁定资源时,就可能会产生死锁;
+ 多个事务同时锁定同一个资源时,也会产生死锁;

为了解决这种问题,数据库系统实现了各种死锁检测和死锁超时机制.

+ 越复杂的系统,比如`InnoDB`存储引擎,越能检测到死锁的循环依赖,并立即返回一个错误.

这种解决方式很有效,否则死锁会导致出现非常慢的查询.

+ 另一种解决方式,就是当查询的时间达到锁等待超时的设定后放弃锁请求;

>`InnoDB`目前处理死锁的方法是:
+ 将持有最少行级排他锁的事务进行回滚;

锁的行为和顺序是和存储引擎相关的.以同样的顺序执行语句,有些存储引擎会产生死锁,有些则不会.

**死锁的产生有双重原因:有些是因为真正的数据冲突,这种情况通常很难避免,但有些则完全是由于存储引擎的实现方式导致的;**

>**`死锁发生以后,只有部分或者完全回滚其中一个事务,才能打破死锁;`**

## 事务日志

事务日志可以帮助提高事务的效率.使用事务日志,存储引擎在修改表的数据时只需要修改其内存拷贝,再把该修改行为记录到持久在硬盘上的事务日志中,而不用每次都将修改的数据本身持久到磁盘.

>+ 事务日志采用的是追加的方式,因此写日志的操作是磁盘上一小块区域内的顺序`IO`,而不像随机`IO`需要在磁盘的多个地方移动磁头,所以采用事务日志的方式相对来说要快得多.
+ 事务日志持久以后,内存中被修改的数据在后台可以慢慢地刷回到磁盘.

**如果数据的修改已经记录到事务日志并持久化,但数据本身还没有写回磁盘,此时系统崩溃,存储引擎在重启时能够自动恢复这部分修改的数据.`具体的恢复方式则视存储引擎而定;`**

## `MySQL`中的事务

`MySQL`提供了两种事务型的存储引擎:`InnoDB`和`NDB Cluster`.另外还有一些第三方存储引擎也支持事务,比较知名的包括`XtraDB`和`PBXT`.

**`MySQL默认采用自动提交(AUTOCOMMIT)模式.`**如果不是显式地开始一个事务,则每个查询都被当作一个事务执行提交操作.

**修改`AUTOCOMMIT`对非事务型的表,比如`MyISAM`或者内存表,不会有任何影响.对这类表来说,没有`COMMIT`或者`ROLLBACK`的概念,也可以说是相当于一直处于`AUTOCOMMIT`启用的模式;**


>+ `MySQL`可以通过执行`SET TRANSACTION ISOLATION LEVEL`命令来设置隔离级别;
  + 新的隔离级别会在下一个事务开始的时候生效;
+ 在配置文件中设置整个数据库的隔离级别;

### 在事务中混合使用存储引擎

`MySQL`服务器层不管理事务,事务是由下层的存储引擎实现的.所以在同一个事务中,使用多种存储引擎是不可靠的;

>+ 如果在事务中混合使用了`事务型`和`非事务型`的表(例如`InnoDB`和`MyISAM`表),在正常提交的情况下不会有什么问题;
+ 如果该事务需要回滚,非事务型的表上的变更就无法撤销,这会导致数据库处于不一致的状态,这种情况很难修复,事务的最终结果将无法确定.
  
**为每张表选择合适的存储引擎非常重要;**

