在数据库中,无论何时,只要有多个查询需要在同一时刻修改数据,都会产生并发控制得问题;

`MySQL`在两个层面进行并发控制:`服务器层`和`存储引擎层`;

## 读写锁

在处理并发读或者写时,可以通过实现一个由两种类型得锁组成得锁系统来解决问题;

这两个类型得锁通常被称为`共享锁(shared lock,读锁)`和`排他锁(exclusive lock,写锁)`;

描述一下锁的概念:
+ 读锁是共享的,或者说是相互不阻塞的.
  + 多个客户在同一时刻可以同时读取同一个资源,而互不干扰.
+ 写锁则是排他的,就是一个写锁会阻塞其他的写锁和读锁;
  + 出于安全策略的考虑,只有这样,才能确保在给定的时间里,只有一个用户能执行写入,并防止其他用户读取正在写入的同一资源;

**在实际的数据库系统中,每时每刻都在发生锁定,当某个用户在修改某一部分数据时,MySQL会通过锁定防止其他用户读取同一数据.大多数时候,MySQL锁的内部管理都是透明的.**

## 锁粒度

一种提高共享资源并发性的方式就是让锁定对象更有选择性.尽量只锁定需要修改的部分数据,而不是所有的资源.

**所谓的锁策略,就是在锁的开销和数据的安全性之间寻求平衡,这种平衡当然也会影响到性能.**

大多数商业数据库系统没有提供更多的选择,一般都是在表上施加`行级锁(row-level lock)`,并以各种复杂的方式来实现,以便在锁比较多的情况下尽可能地提供更好的性能;

>每种`MySQL存储引擎都可以实现自己的锁策略和锁粒度.`

### `表锁(table lock)`

`表锁`是MySQL中最基本的锁策略,并且是开销最小的策略.

表锁,它会锁定整张表.一个用户在对表进行写操作(插入,删除,更新等)前,需要先获得写锁,这会阻塞其他用户对该表的所有读写操作.只有没有写锁时,其他读取的用户才能获得读锁,读锁之间是不相互阻塞的;

### `行级锁(row lock)`

行级锁可以最大程度地支持并发处理(同时也带来了最大的锁开销).

在`InnoDB`和`XtraDB`,以及其他一些存储引擎中实现了行级锁.

行级锁只在存储引擎层实现,而MySQL服务器层没有实现.服务器层完全不了解存储引擎中的锁实现.

### 多版本并发控制

`MySQL`的大多数事务型存储引擎是实现的都不是简单的行级锁.

基于提升并发性能的考虑,它们一般都同时实现了`多版本并发控制(MVCC)`.不仅是`MySQL`,包括`Oracle`,`PostgreSQL`等其他数据库系统也都实现了`MVCC`,但各自的实现机制不尽相同,因为`MVCC`没有一个统一的实现标准;

`MVCC`是行级锁的一个变种,但是它在很多情况下避免了加锁操作,因此开销更低.虽然实现机制有所不同,但大都实现了非阻塞的读操作,写操作也只锁定必要的行;

>`MVCC`的实现,是通过保存数据在某个时间点的快照来实现的;
+ 不管需要执行多长时间,每个事务看到的数据都是一致的.
+ 根据事务开始的时间不同,每个事务对同一张表,同一时刻看到的数据可能是不一样的.

**存储引擎的`MVCC`实现典型有`乐观(optimistic)并发控制`和`悲剧(pessimistic)并发控制`;**

>**`InnoDB`的MVCC:**
+ **通过在每行记录后面保存`两个隐藏的列`来实现的.**
  + 这两个列,一个保存了行的创建时间,一个保存行的过期时间(或删除时间);
+ 当然存储的并不是实际的时间值,而是系统版本号(system version number);
+ `每开始一个新的事务,系统版本号都会自动递增`;
+ 事务开始时刻的系统版本号会作为事务的版本号,用来和查询到的每行记录的版本号进行比较.

1. `SELECT`
  + `InnoDB`会根据以下两个条件检查每行记录:
    + `InnoDB`只查找版本早于当前事务版本的数据行,这样可以确保事务读取的行,要么是在事务开始前已经存在的,要么是事务自身插入或者修改过的;
      + **行的系统版本号小于或等于事务的系统版本号**
    + 行的删除版本要么未定义,要么大于当前事务版本号.
      + 确保事务读取到的行,在事务开始之前未被删除;
2. `INSERT`
  + `InnoDB`为新插入的每一行保存当前系统版本号作为行版本号;
3. `DELETE`
  + `InnoDB`为删除的每一行保存当前系统版本号作为行删除标识;
4. `UPDATE`
  + `InnoDB`为插入一行新纪录,保存当前系统版本号作为行版本号,同时保存当前系统版本号到原来的行作为行删除标识;


**`MVCC`只在`REPEATABLE READ`和`READ COMMITTED`两个隔离级别下工作.其他两个隔离级别都和`MVCC`不兼容,因为`READ UNCOMMITTED`总是读取最新的数据行,而不是符合当前事务版本的数据行.而`SERIALIZABLE`则会对所有读取的行都加锁.**
