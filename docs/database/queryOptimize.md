**关系数据库的理论就是关于数据表,集合以及对它们进行操作的理论.**

数据库是数据表的集合,数据表是数据行和数据列的集合.

>当你发出一个`SELECT`语句来从数据表中检索数据行时,你得到的是另外一个数据行和数据列的集合,也就是另一个数据表.


查询的概念上是集合操作,因而再集合理论中没有关于时间的概念.然而,现实情况下查询要占用时间,有时甚至长得令人厌烦.于是我们把对集合瞬时准确操作的抽象概念放在一边,继而寻找能够加快查询的方法:

+ 为数据表创建索引以使数据库服务器能更快地查阅数据行;
+ 看看如何写出查询以最大程度地利用哪些索引,使用`EXPLAIN`语句检查`MySQL`服务器时候真的如期行事;
+ 编写查询来影响服务器的调度机制,从而使来自多个客户程序的查询能够更好地协作;
+ 修改服务器的操作参数以提高它的工作效率;
+ 分析底层硬件在做些什么,分析如何解决物理限制,从而提高性能;

## 使用索引

通常,能够造成查询速度最大差异的是索引的正确使用.

### 索引的优点

`一个没有索引的数据表就是一个无序的数据行集合`;当我们需要一个数据行时,就需要检查数据表的每一个数据行,看它是否与期望值匹配.这就是一个数据表的完整扫描,如果数据表很大,但是仅有少数几个记录与搜索条件相匹配,那么工作过程就很慢;

+ 当有索引时,由于索引值是经过分类的,我们可以得知匹配数据行在什么位置结束,从而跳过其余部分.
+ 其次定位算法的使用,查找时不用从索引开始位置经过线性扫描就能直接就找到第一个匹配项.

**此外,索引中的数据行通常都要比数据文件的数据行短一些.当你插入或删除数值时,来回移动较短的索引数值来保持分类顺序要比来回移动较长的数据文件的数据行方便一些;**

> `MyISAM`数据表而言:
+ 数据表的数据行是在数据文件里,而索引值是在索引文件里.
+ 一个数据表可以有多个索引;
+ 所有的索引都存储在同一个索引文件里.索引文件里的每一个索引都是由分类的关键记录数组组成的,这些数组用于快速访问数据文件;

>`InnoDB`数据表而言:
+ 存储引擎使用的是一个表空间;
+ 表空间里面,管理着所有`InnoDB`类型数据表的数据和索引的存储.


`MySQL`使用索引的方式有以下几种:
+ 索引的用途:
  + 在查询操作中把与`WHERE`子句所给出的条件相匹配的数据行尽快找出来;
  + 在关联操作中把与其他数据表里的数据行相匹配的数据行尽快找出来;
+ 使用`MIN()`或`MAX()`函数的查询,如果数据列带索引,那么它的最小值和最大值能够被迅速找到而不用通过逐行检查的方法来查找;
+ 迅速完成`ORDER BY`子句和`GROUP BY`子句的分类和分组操作;
+ 避免为一个查询整体读取数据行;

### 索引的缺点

+ 索引加快了检索速度,但是却降低了在带索引的数据列里插入,删除以及修改数值的速度;
  + 索引降低了许多涉及写入的操作的速度.
  + 写入一条数据行不仅要求写入到数据行,它还要求所有索引都要做出改变.
+ 索引要占据磁盘空间,多个索引会占据更大的空间;
  + `MyISAM`类型的数据表来说,大量地索引一个数据表有可能使索引文件比数据文件更快地到达它的最大尺寸;
  + `InnoDB`共享表空间里的全部`InnoDB`数据表分享着同一个存储空间,添加索引会使表空间里用于存储的空间更快地减少.
    + `InnoDB`数据表的共享表空间不受操作系统文件尺寸的限制,因为它可以包含多个文件;如果你有一个附加磁盘空间,可以对它添加新的部件来扩充表空间;
  + 单独表空间的`InnoDB`数据表把数据和索引集中保存在同一个文件里,增加索引将导致数据表的尺寸更快地逼近最大文件长度;

**`如果不需要某个特定的索引来加快查询速度,就不要创建它;`**

## 挑选索引

1. 尽量为用来搜索,分类或分组的数据列编制索引,不要为作为输出显示的数据列编制索引;

>最适合有索引的数据列
+ 哪些在`WHERE`子句中出现的数据列;
+ 在联结子句中给出的数据列;
+ 在`ORDER BY`或`GROUP BY`子句中出现的数据列;

2. 综合考虑各数据列的维度;(**`数据列的维度等于它所容纳的非重复值的个数.`**)
  + 数据列的维度越高(维度的最大值等于数据表里的数据行的个数),索引使用效果越好;

3. 对短小的值进行索引:
  + 短小的值可以让比较操作更快地完成,加快索引查找速度;
  + 短小的值可以让索引的"体积"更小,减少磁盘`IO`活动;
  + 短小的键值意味着键缓存里的索引块可以容纳更多的键值,让`MySQL`可以在内存里同时容纳更多的键,而这将加大在不需要从磁盘读取更多索引快的前提下在内存里找到键值的概率;

**`InnoDB`存储引擎而言,因为它使用的是聚簇索引,让主键尽量短小将更有好处;(`聚簇索引`是指把数据行和主键值集中保存在一起的情况.其他的索引都是些二级索引(它们保存着主键值和二级索引值))先在二级索引里找到一个主键值,再通过它找到相应的数据行.意味着主键值再每一个二级索引里都会重复出现,如果主键值比较长的话,就会导致每一个二级索引都将需要占用更多的存储空间;**

4. 为字符串值得前缀编索引

5. 充分利用最左边得前缀
  + 一个复合索引在工作时就相当于`n`个索引,因为索引中最左边得数据列集合能够用于匹配数据行.

6. 适可而止,不要建立过多得索引

7. 让索引得类型与你打算进行的比较操作的类型保持匹配
  + 对于`散列索引`,会有一个散列函数来依次处理每一个数据列值.结果`散列值`将被存入该索引并用来进行查询;
    + 散列索引在使用`=`或`<>`操作符进行行的精确匹配比较操作里速度极快;
    + 用来查找一个范围的比较操作里表现不佳;
  + `B树`索引在使用`<``<=``=``=>``>``<>``!=`和`BETWEEN`操作符进行的精确比较操作或范围比较操作都很有效率.还可以用于使用`LIKE`操作符进行的模式匹配操作;

8. 利用"慢查询"日志找出性能低劣的查询

## 查询优化器的工作原理

查询优化程序有好几个目标,主要目的是只要可能就要使用索引,并且要使用条件最严格的索引来尽可能多,尽可能快地排除哪些不符合索引条件的数据行;

>**查询优化器从搜索范围中排除数据行的速度越快,找到哪些与搜索条件匹配的数据行也就越快.**


+ 对数据表进行分析:
  + 生成关于索引值分布情况的统计数据,它们可以帮助优化器对索引的使用效果做出更准确的评估;
  + 对于`MyISAM`和`InnoDB`数据表,可以主动地使用`ANALYSE TABLE`语句让服务器对键值进行一次分析;
+ 使用`EXPLAIN`语句来验证优化器操作:
  + `EXPLAIN`语句可以告诉你某给定查询有没有使用索引.
+ 向优化器提供提示或在必要时屏蔽之;
  + 在某个数据表名字后面利用`FORCE INDEX`,`USE INDEX`或`IGNORE INDEX`限定词告诉服务器你想使用哪些索引;
  + 利用`STRAGHT_JOIN`强制优化器按特定的顺序使用数据表.
    + 在正常情况下,`MySQL`优化器会自行确定按照何种顺序扫描数据表才能最快地把数据行检索出来;但在少数场合,优化器做出的决定并不一定是最优的.
+ 尽量使用数据类型相同的数据列进行比较;
+ 使带索引的数据列在比较表达式中单独出现;
  + 如果函数调用中使用了一个数据列,或者使将数据列作为算术表达式中很复杂的项目中的一部分,`MySQL`将不能使用索引,因为它必须要对每一个数据行计算出表达式的值;
+ 不要在`LIKE`模式的开始位置使用通配符;
+ 利用优化器的长处
+ 试验各种查询的变化格式,而且要多次运行它们;
+ 避免过多使用`MySQL`的自动类型转换功能;

## 为提高查询效率而挑选数据类型

+ 尽量使用数值操作,少使用字符串操作
  + 数值之间的比较只用一个操作就可以完成;
  + 而字符串之间的比较一般需要进行多次子节与子节或字符与字符的比较才能完成,而且字符串越长,比较的次数就越多;
+ 如果你能选择数据行的存储格式,就应该尽量选用最适用于你的存储引擎的格式
  + 对于`MyISAM`数据表,就应该尽量选用固定长度的数据列而不是可变长度的数据列.
    + 对于可变长度的数据行,因为数据行的长度不一致,所以在经过许多删除或更新操作后将形成更多的碎片;
    + 如果数据表发生崩溃,固定长度的数据行更容易重新构造;
+ 尽量把数据列声明为`NOT NULL`
  + `MySQL`不再需要在查询处理期间检查该数据列的值是不是`NULL`;
+ 考虑使用`ENUM`数据列
+ 利用`PROCEDURE ANALYSE()`语句分析数据表;
+ 对容易产生碎片的数据表进行整理;
+ 把数据压缩到`BLOB`或`TEXT`数据列里;
+ 使用人造索引
+ 尽量避免对很大的`BLOB`或`TEXT`值进行检索
+ 把`BLOB`或`TEXT`数据列剥离到单独一个数据表里