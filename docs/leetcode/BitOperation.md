
## 位运算规律

运算类型|--|--|--|--|
--|--|--|--|--|
与（&）|0 & 0 = 0|1 & 0 = 0| 0 & 1 = 0|1 & 1 = 1|
或|0 或 0 = 0|1 或 0 = 1|0 或 1 = 1|1 或 1 = 1|
异或（^）|0 ^ 0 = 0|1 ^ 0 = 1|0 ^ 1 = 1|1 ^ 1 = 0|


左移运算符 `m << n` 表示把m左移n位。左移n位的时候，最左边的n位将被丢弃，同时在最右边补上n个0；

右移运算符`m >> n`表示把m右移n位。右移n位的时候，最右边的n位将被丢弃。
  + 如果数字是一个无符号数值，则用0填补最左边的n位。
  + 如果数字是一个有符号数值，则用数字的符号位填补最左边的n位。
    + 如果数字是一个正数，则右移之后在最左边补n个0；
    + 如果数字是一个负数，则右移之后在最左边补n个1；

## 问题

请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。

Example:

```
9 二进制：1001，有2位是1；
所以输入9，该函数输出2；
```

## solution

```
public int hammingWeight(int n) {
        int count = 0;
        while(n != 0){
            count += n & 1;
            n = n >>> 1;
        }
        
        return count;
}
```

>+ 如果输入一个负数时，右移一位，为了保证移位后是个复数，最高位会设为1；
+ 如果一直右移运算，最终这个数字就会变成`0xffffffff`而陷入死循环；


>+ 把一个整数减去1，再和原整数做与运算，会把该整数最右边一个1变成0；
+ 那么一个整数的二进制表示中有多少个1，就可以进行多少次操作；

```
public int calcBitPro(int n){
        int count = 0;
        while (n != 0){
            ++count;
            n = (n - 1) & n;
        }
        return count;
    }
```