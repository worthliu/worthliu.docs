`0，1，...，n-1`这n个数字排成一个圆圈，从数字`0`开始每次从这个圆圈里删除第`m`个数字。求出这个圆圈里剩下的最后一个数字；

### 题解

在圆圈中每次删除第m个数字，只剩下最后一个数字；

这个问题是有名的约瑟夫环问题：
+ 用环形链表模拟圆圈的经典解法；
+ 分析每次被删除的数字的规律并直接计算出圆圈中最后剩下的数字；

>+ 定义一个关于n和m的函数`f(n, m)`,表示每次在n个数字`0，1，...，n-1`中每次删除第m个数字最后剩下的数字；
+ n个数字中，第一个被删除的数字是`(m - 1) % n`，把`(m - 1) % n`记为k，那么删除k之后剩下的`n-1`个数字为`0，1，...，k-1，k+1，...，n-1`，并且下一次删除从数字`k+1`开始计数。
+ 剩下的序列中，`K+1`排在最前面，从而形成`k+1，...，n-1，0，1，...，k-1`；该序列最后剩下的数字也是关于关于n和m的函数。记`f'(n, m)`,且`f(n, m)=f'(n-1, m)`；
+ 序列下标规则映射p，则`p(x)=(x-k-1)%n`，它表示如果映射前的数字是x，那么映射后的数字是`(x-k-1)%n`。该映射的逆映射是`~p(x)=(x+k+1)%n`；
+ 最终剩下数字：`f'(n-1,m)=~p[f(n-1,m)]=[f(n-1,m) + k + 1] %n`,把`k=(m-1)%n`代入得到`f(n, m)=f'(n-1, m)=[f(n-1, m) + m]%n`;

## solution

```
	public int lastRemainingPro(int n, int m){
        if(n < 1 || m < 1){
            return -1;
        }
        //
        int last = 0;
        for(int ind = 2; ind <= n; ++ind){
            last = (last + m) % ind;
        }
        return last;
    }
```