输入一个整型数组，数组里有正数也有负数，数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的大值。要求时间复杂度为O(n);

### 题解


最直观是，枚举出数组的所有子数组并求出它们的和；一个长度为n的数组，总共有`n(n+1)/2`个子数组；计算出所有子数组的和，最快也需要`O(n^2)`的时间；

计算数组`{1, -2, 3, 10, -4, 7, 2, -5}`

步骤|操作|累加的子数组和|最大的子数组和|
--|--|--|--|
1|+1|1|1|
2|-2|-1|1|
3|抛弃前面的和-1，+3|3|3|
4|+10|13|13|
5|-4|9|13|
6|+7|16|16|
7|+2|18|18|
8|-5|13|18|


用动态规划的思想来分析这个问题,如果用函数f(i)表示以第i个数字结尾的子数组的最大和,那么需要求出max[f(i)]，其中`0<=i<n`。
递归公式：

f(i)=num[i] `i=0或者f(i-1)<=0`,f(i-1)+num[i] `i!=0且f(i-1)>0`

>+ 当以第i-1个数字结尾的子数组中所有数字的和小于0时，如果把这个负数与第i个数累加，得到的结果比第i个数字本身还要小，所以这种情况下以第i个数字结尾的子数组就是第i个数字本身。
+ 如果以第i-1个数字结尾的子数组中所有数字的和大于0，与第i个数字累加就得到以第i个数字结尾的子数组中所有数字的和；

## solution


>**java实现中，需要注意最小值的比较**

```
	public int maxSubArray(int[] nums) {
        if(nums == null || nums.length <= 0){
            return 0;
        }
        //
        int nCurSum = 0;
        int nGreatestSum = 0x80000000;
        for(int num : nums){
            if(nCurSum <= 0){
                nCurSum = num;
            }else{
                nCurSum += num;
            }
            //
            if(nCurSum > nGreatestSum){
                nGreatestSum = nCurSum;
            }
        }
        return nGreatestSum;
    }
```

```
```