`Redis`并没有直接使用自身所定义的数据结构来是实现键值对数据库.而是基于这些数据结构建立一个对象系统.

包含字符串对象,列表对象,哈希对象,集合对象和有序集合对象这五种类型的对象;

通过这五种不同类型的对象,`Redis`可以在执行命令之前,根据对象的类型来判断一个对象是否可以执行给定的对象.

**`Redis的对象系统还实现呢基于引用计数计数的内存回收机制,当程序不再使用某个对象的时候,这个对象所占用的内存就会被自动释放;`**

## `对象的类型与编码`

每次在`Redis`的数据库中新创建一个键值对时,至少会创建两个对象:`键对象与值对象`;

>**`Redis中每个对象都由一个redisObject结构表示,该结构中和保存数据有关的三个属性分别是type属性/encoding属性和ptr属性.`**

通过`encoding`属性来设定对象所使用的编码,而不是为特定类型的对象关联一种固定的编码,极大地提升了`Redis`的灵活性和效率,因为`Redis`可以根据不同的使用场景来为一个对象设置不同的编码,从而优化对象在某一场景下的效率.

## `字符串对象`

字符串对象的编码可以是`int`,`raw`或者`embstr`;

+ 如果一个字符串对象保存的是整数值,并且这个整数值可以用`long`类型来表示,那么字符串对象会将整数值保存在字符串对象结构的`ptr`属性里面(将`void*`转换成`long`),并将字符串对象的编码设置为`int`;

+ 如果字符串对象保存的是一个字符串值,并且这个字符串值得长度大于32字节,那么字符串对象将使用一个简单动态字符串(SDS)来保存这个字符串值,并将对象得编码设置为`raw`;

+ 如果字符串对象保存得是一个字符串值,并且这个字符串得长度小于等于32字节,那么字符串对象将使用`embstr`编码得方式来保存这个字符串值;


>+ `embstr`编码是专门用于保存短字符串得一种优化编码方式,与`raw`编码一样;
+ 都使用`redisObject`结构和`sdshdr`结构来表示字符串对象;
+ `raw`编码会调用两次内存分配函数来分别创建`redisObject`结构和`sdshdr`结构;
+ `embstr`编码则通过调用一次内存分配函数来分配一块连续得空间,空间中依此包含`redisObject`和`sdshdr`两个结构;


**`int`编码的字符串队形和`embstr`编码的字符串对象再条件满足的情况下,会被转换为`raw`编码的字符串对象.**

## `列表对象`

`列表对象`的编码可以是`ziplist`或者`linkedlist`.
+ `ziplist`编码的列表对象使用压缩列表作为底层实现,每个压缩列表节点(`entry`)保存了一个列表元素.
+ `linkedlist`编码的列表对象使用双端链表作为底层实现,每个双端链表节点(`node`)都保存了一个字符串对象,而每个字符串对象都保存了一个列表元素.

>编码转换:
+ 当列表对象可以同时满足以下两个条件时,列表对象使用`ziplist`编码:
  + 列表对象保存的所有字符串元素的长度都小于64字节;
  + 列表对象保存的元素数量小于512个;
  + **不能满足这两个条件的列表对象需要使用`linkedlist`编码.**
  + 条件的上限值通过配置文件修改:
    + `list-max-ziplist-value`
    + `list-max-ziplist-entries`

## `哈希对象`

`哈希对象`的编码可以是`ziplist`或者`hashtable`;
+ `ziplist`编码的哈希对象使用压缩列表作为底层实现,每当有新的键值对要加入到哈希对象时
  + 程序会先将保存了键的压缩列表节点推入到压缩列表表尾;
  + 再将保存了值得压缩列表节点推入到压缩列表表尾;
    + 保存了同一键值对得两个节点总是紧挨在一起,保存键得节点在前,保存值得节点在后;
    + 先添加到哈希对象中键值对会被放在压缩列表得表头方向,而后来添加到哈希对象中键值对会被放在压缩列表得表尾方向;
+ `hashtable`编码得哈希对象使用字典作为底层实现,哈希对象中得每个键值对都使用一个字典键值对来保存;
  + 字典的每个键都是一个字符串对象,对象中保存了键值对的键;
  + 字典的每个键都是一个字符串对象,对象中保存了键值对的值;


>编码转换:
+ 当哈希对象可以同时满足以下两个条件时,哈希对象使用`ziplist`编码:
  + 哈希对象保存的所有键值对的键和值的字符串长度都小于64字节;
  + 哈希对象保存的键值对数量小于512个;
  + **不能满足两个条件的哈希对象需要使用`hashtable`编码;**
  + 条件的上限值通过配置文件修改:
    + `hash-max-ziplist-value`
    + `hash-max-ziplist-entries`

## `集合对象`

`集合对象`的编码可以是`intset`或者`hashtable`:
+ `intset`编码的集合对象使用整数集合作为底层实现,集合对象包含的所有元素都被保存在整数集合里面;
+ `hashtable`编码的集合对象使用字典作为底层实现,字典的每个键都是一个字符串对象,每个字符串对象包含了一个集合元素,而字典的值则全部被设置为`NULL`;


>编码转换;
+ 当集合对象可以同时满足以下两个条件时,对象使用`intset`编码:
  + 集合对象保存的所有元素都是整数值;
  + 集合对象保存的元素数量不超过512个;
  + **不能满足这两个条件的集合对象需要使用`hashtable`编码;**
  + 第二个条件上限值通过配置文件修改:
    + `set-max-intset-entries`


## `有序集合对象`

有序集合的编码可以是`ziplist`或者`skiplist`:
+ `ziplist`编码的压缩列表对象使用压缩列表作为底层实现,每个集合元素使用两个紧挨在一起的压缩列表节点来保存.第一个节点保存了元素的成员(`member`),而第二个元素则保存元素的分值(`score`);
  + 压缩列表内的集合元素按分值从小到大进行排序,分值较小的元素被放置在靠近表头的方向,而分值较大的元素则放在靠近表尾的方向;
+ `skiplist`编码的有序集合对象是使用`zset`结构作为底层实现,一个`zset`结构同时包含一个字典和一个跳跃表;
  + `zset`结构中的`zsl`跳跃表按分值从小到大保存了所有集合元素,每个跳跃表节点都保存了一个集合元素:
    + 跳跃表节点的`object`属性保存了元素的成员,而跳跃表节点的`score`属性则保存了元素的分值.
    + **`ZRANK`,`ZRANGE`等命令就是基于跳跃表API来实现的.**
  + `zset`结构中的`dict`字典为有序集合创建了一个从成员到分值的映射,字典中的每个键值对都保存了一个集合元素:
    + 字典的键保存了元素的成员,而字典的值则保存了元素的分值.
    + **`ZSCORE`命令就是根据字典以`O(1)`复杂度查找给定成员的分值.**


>**有序集合每个元素的成员都是一个字符串对象,而每个元素的分值都是一个`double`类的浮点数.虽然`zset`结构同时使用`跳跃表`和`字典`来保存有序集合元素,但`这两种数据结构都会通过指针来共享相同元素的成员和分值`,所以同时使用`跳跃表`和`字典`来保存集合元素不会产生任何重复成员的或者分值,也不会因此而浪费额外的内存.**

>`为什么有序集合需要同时使用跳跃表和字典来实现:`
+ 理论上,有序集合可以单独使用`字典`或者`跳跃表`的其中一种数据结构来实现,但是无论单独使用字典还是跳跃表,在性能上对比起同时使用字典和跳跃表都会有所降低.
+ 只使用`字典`是实现有序集合,那么虽然以`O(1)`复杂度查找成员的分值特性会被保留,但是,字典以无序的方式来保存集合元素,所以每次在执行范围型命令操作时至少需要`O(NlogN)`时间复杂度,以及额外的`O(N)`内存空间(`因为要创建一个数组来保存排序后的元素.`).
+ 只使用`跳跃表`来实现有序集合,那么跳跃表执行范围型操作所有优点都会被保留,但是查找分值操作复杂度将从`O(1)`上升为`O(logN)`.


>编码转换:
当有序集合对象可以同时满足以下两个条件时,对象使用`ziplist`编码:
+ 有序集合保存的元素数量小于`128`个
+ 有序集合保存的所有元素成员的长度都小于`64`字节;
+ 不能满足以上两个条件的有序集合对象将使用`skiplist`编码.
+ **条件上限值通过配置文件修改:**
  + `zset-max-ziplist-entries`
  + `zset-max-ziplist-value`


## `类型检查与命令多态`

`Redis`中用于操作键的命令基本上可以分为两种类型:
+ 可以对任何类型的键执行:
  + `DEL`,`EXPIRE`,`RENAME`,`TYPE`,`OBJECT`等
+ 只能对特定类型的键执行:
  + SET,GET,APPEND,STRLEN等命令只能对字符串键执行;
  + HDEL,HSET,HGET,HLEN等命令只能对哈希键执行;
  + RPUSH,LPOP,LINSERT,LLEN等命令只能对列表键执行;
  + SADD,SPOP,SINTER,SCARD等命令只能对集合键执行;
  + ZADD,ZCARD,ZRANK,ZSCORE等命令只能对有序集合键执行;

**为了确保只有指定类型的键可以执行某些特定的命令,在执行一个类型特定的命令之前,Redis会先检查输入键的类型是否正确,然后再决定是否执行给定的命令.**
+ 类型特定命令所进行的类型检查时通过`redisObject`结构的`type`属性来实现的;


>**Redis除了会根据值对象的类型来判断是否能够执行指定命令之外,还会根据值对象的编码方式,选择正确的命令实现代码来执行命令.**

## `内存回收`

由于C语言并不具备自动内存回收功能,所以Redis再自己的对象系统中构建了一个引用计数(`reference counting`)技术实现的内存回收机制,通过这一机制,程序可以通过跟踪对象的引用计数信息,在适当的时候自动释放对象并进行内存回收.
+ 在创建一个新对象时,引用计数的值会被初始化为1;
+ 当对象被一个新程序使用时,它的引用计数值会被+1;
+ 当对象不再被一个程序使用时,它的引用计数值会被-1;
+ 当对象的引用计数值变为0时,对象所占用的内存会被释放;

## `对象共享`

除了用于实现引用计数内存回收机制之外,对象的引用技术属性还带有对象共享的作用.

在`Redis`中,让多个键共享同一个值对象需要执行以下两个步骤:
+ 键数据库键的值指针指向一个现有的值对象;
+ 将被共享的值对象的引用计数增一;

## `对象的空转时长`

`redisObject`结构包含的最后一个属性为`lru`属性,该属性记录了对象最后一次被命令程序访问的时间:
+ `OBJECT IDLETIME`命令可以打印出给定键的空转时长,这一空转时长就是通过将当前时间减去键的值对象的`lru`时间计算得出的;
+ 键的空转时长,如果服务器打开了`maxmemory`选项,并且服务器用于回收内存的算法为`volatile-lru`或者`allkeys-lru`,那么当服务器占用的内存数超过了`maxmemory`选项所设置的上限值时,空转时长比较高的那部分键会优先被服务器释放,从而回收内存;
