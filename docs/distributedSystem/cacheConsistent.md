典型的web应用程序引入了缓存系统，比如memcache或redis，以期减少负载用于读取请求热数据的主数据库请求。最原始的设计类似于下图。

![originalCache](/images/originalCache.png)

不幸的是，尽管它引入了许多问题，这个设计还是很常见的。我见过一些
拥有大规模应用程序的组织仍在使用这个设计，并且他们雇佣了许多技术人员来克服这些随着系统的操作复杂性增加带来的问题，有时甚至是表面不一致的数据给最终用户。

### 问题1。每个web服务器实例的缓存服务的连接池

在大型应用程序中，有时会有数千个web服务器实例(特别是在较慢的语言中，Ruby)托管着web应用程序。每台服务器都必须维护与网络基础设施的通信，应用程序代码直接与之通信。这可以包括主数据库如`MSSQL,MySQL，
Oracle,Postgres`和缓存服务，如Memcache或Redis。例如，每个web服务器实例对于与它通信的每个数据库或缓存服务实例，都有一个连接池。

![connectPoolCachePartOne](/images/connectPoolCachePartOne.png)
![connectPoolCachePartTwo](/images/connectPoolCachePartTwo.png)

这可能会对web服务器上的资源造成压力，但更重要的是数据库或缓存服务，如图2所示。这就是为什么在Redis服务器库的基准测试中包含了一个16384个连接基准，以便查看它们是如何缩放的。在这样一个大型系统中，可以看到一个Memcache或Redis服务器的10000或20000个连接。

### 问题2。许多web应用程序请求必须执行缓存集操作

类似于HTTP请求可能会发出多个`SQL INSERT`或`UPDATE`语句，对缓存服务发出多个SET操作。即使这些操作可以异步完成，它们仍然消耗web服务器上的资源，如果web服务器只需要更新主数据库，那就太好了。

### 问题3。没有容错。如果缓存集操作失败，数据将丢失
如何设计如上图一样的web应用程序架构中的典型操作序列：

+ 更新主数据库(MSSQL、MySQL、Oracle、Postgres等)。
+ 如果事务失败，返回一个HTTP错误。
+ 如果事务成功将SET操作发送到缓存服务器(memcache、redis等)。

任何SET操作都可能失败,即便在重新尝试情况下,缓存服务器(s)与主数据库也有可能不一致的，这将导致用户看到不正确的信息。更糟糕的是，根据应用程序的设计，对于部分失败是可以容忍的，这导致用户在更改和缓存命中后可能看到部分正确和部分不正确的信息。

一些缓存服务协议支持在一个命令中发送多个SET操作，但有些则不支持。

并不是所有的web应用程序都足够智能，可以将不同区域的应用发送过来的单个命令有效组织为SET操作。如果是这样的话，你可能会有部分失败，其中一些SET操作成功了，有些失败了。

在重新尝试之外，web应用程序无法做很多事情来最终纠正丢失的缓存SET操作。它必须在某个时刻重试并放弃。缓存将提供缓存命中与主数据库不一致，直到通过TTL或其他进程使缓存键失效。

### 消息中间件
有时，这可以通过像Kafka这样的消息传递中间件来解决，web应用程序将把SET操作推送给Kafka，消费者从Kafka中拉出更改，并在缓存服务上执行SET操作。这大大增加了缓存一致性，并允许缓存在失败后存活，并在短时间或长时间失败后继续捕获。

这就引入了系统中的延迟。更改可能不会立即被用户看到。一些web应用程序通过在web应用程序中进行粘性会话和内缓存来隐藏数据的不一致，从而解决了这个问题。如果web服务器失败，并请求路由到另一个web服务器实例，那么仍然可能会出现陈旧的结果。这在系统的请求路由层引入了复杂性。

![messageMiddleCache](/images/messageMiddleCache.png)

如上图所示，这大大减少了缓存服务的连接负载，但引入了许多操作复杂性，比如以下内容。

+ 部署和操作一个高吞吐量的消息传递系统，如Kafka集群部署。
+ 部署和操作多个消费者消费Kafka的消息，并在缓存服务中执行SET操作，以抵御消费者的失败。

### 问题4。与主数据库没有顺序一致性
Leslie Lamport描述了连续的一致性。
执行的结果与所有处理器执行的顺序相同，每个处理器的操作按照程序中指定的顺序出现在这个序列中。

上图极大地提高了容错性，减少了丢失更新的机会，但是没有处理顺序。问题3描述了完整和部分失败的可能性，并解释了用户如何看到部分更新和部分陈旧的结果。在后续行动成功之前，进行更深层次的操作可能会失败。可见变化的顺序可能是无序的。有些应用程序可能对这种不一致性更加敏感。有些应用程序可能需要严格的部分顺序。即使订单不是关键，为用户提供连续的一致性也是更好的体验，减少混乱。


### 解决方案:MySQL binlog复制
上图显示了共享消息队列的好处，但是部署一个具有容错能力的队列并不是微不足道的，而且运行顺畅也不是小事。如果您使用带有复制的数据库，系统中已经有一个队列，您可能不需要部署另一个队列和新的基础设施，比如Kafka来解决这些问题。

![binlog](/images/binlog.png)


MySQL有一个用于主/次复制的binlog复制协议。这本质上是一个复制的队列，该队列拥有所有记录在顺序中的事务，如图4所示。这不是一个流行的解决方案，但我说，为什么不呢?
它工作得很好。您可以编写一个应用程序，它可以使用MySQL binlog复制协议，它使用binlog条目并对缓存服务执行SET操作。有两种方法可以使用binlog数据。

+ 解释原始的SQL语法和问题集操作。
+ web应用程序嵌入缓存键作为对SQL的注释。

这两个选项都很好，因为如果需要的话，甚至可以在binlog语句中获取每个事务的事务范围，如果目标系统支持原子多集操作。我推荐第二个选项，因为它更容易解析，而且在大多数情况下应用程序已经有了这个信息。

![binlogCache](/images/binlogCache.png)


图5显示了使用binlog复制的总体架构。

#### 好处

+ 极大地减少了缓存服务上的连接负载。Web服务器只连接到数据库。
+ 顺序一致性，因为我们正在读取数据库提交到缓存服务。
+ 可以连接到复制链中的任何MySQL副本，因为它们都是顺序一致的。

使用Kafka,减少基础设施简化了架构，降低了操作复杂性。通过复制MySQL提交日志到缓存服务，我们增加了一致性，并在数据库和缓存服务之间获得了严格的部分顺序。
