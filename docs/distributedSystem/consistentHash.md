### 负载均衡算法

在做服务器负载均衡时候可供选择的负载均衡的算法有很多，包括： `轮循算法(Round Robin)`、`哈希算法(HASH)`、`最少连接算法(Least Connection)`、`响应速度算法(Response Time)`、`加权法(Weighted )`等。其中哈希算法是最为常用的算法.

典型的应用场景是： 有`N`台服务器提供缓存服务，需要对服务器进行负载均衡，将请求平均分发到每台服务器上，每台机器负责`1/N`的服务。

常用的算法是对hash结果取余数` (hash() mod N )`：对机器编号从0到N-1，按照自定义的`hash()`算法，对每个请求的`hash()`值按N取模，得到余数i，然后将请求分发到编号为i的机器。

但这样的算法方法存在致命问题，如果某一台机器宕机，那么应该落在该机器的请求就无法得到正确的处理，这时需要将当掉的服务器从算法从去除，此时候会有`(N-1)/N`的服务器的缓存数据需要重新进行计算;如果新增一台机器，会有`N /(N+1)`的服务器的缓存数据需要进行重新计算。对于系统而言，这通常是不可接受的颠簸(因为这意味着大量缓存的失效或者数据需要转移)。

那么，如何设计一个负载均衡策略，使得受到影响的请求尽可能的少呢?


### 衡量哈希算法的标准

>+ 平衡性：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。
+ 单调性：单调性是指如果已经有一些数据通过哈希分配到了相应的机器上，又有新的机器加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的机器中去，而不会被映射到旧的机器集合中的其他机器上。
+ 分散性:
+ 负载:

### 一致Hash算法

一致性哈希算法(Consistent Hashing Algorithm)是一种分布式算法，常用于负载均衡。Memcached client也选择这种算法，解决将key-value均匀分配到众多Memcached server上的问题。它可以取代传统的取模操作，解决了取模操作无法应对增删Memcached Server的问题(增删server会导致同一个key,在get操作时分配不到数据真正存储的server，命中率会急剧下降)。


#### 算法原理
>+ 先构造一个长度为`2^32`的整数环（这个环被称为一致性Hash环）;
+ 根据节点名称的Hash值（其分布为`[0, 2^32-1]`）将服务器节点放置在这个Hash环上;
+ 然后根据数据的Key值计算得到其Hash值（其分布也为`[0, 232-1]`），接着在Hash环上顺时针查找距离这个Key值的Hash值最近的服务器节点，完成Key到服务器的映射查找。



