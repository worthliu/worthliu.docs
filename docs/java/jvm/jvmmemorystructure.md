## JVM内存结构

JVM在Java程序运行时会将内存划分成几个特定数据区域,每个数据区域都有特定内存管理方法:

![jvmmemorystructure](/images/jvmmemorystructure.png)

>1. **程序计数器**：用于保存当前正在执行的程序的内存地址,每个线程都有一个独立计数器,线程所有且线程安全;
2. **Java虚拟机栈**: 线程私有，它的生命周期与线程相同;虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个**`栈帧用于存储局部变量表、操作栈、动态链接、方法出口等信息`**。每个方法被调用直到执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程(`-Xss:设置栈帧的大小`)
  + 局部变量表存放了编译期可知的各种基本数据类型、对象引用和方法返回地址；
  + 局部变量表所需的内存空间在编译期间完成分配；
  + 超过栈深度最大值抛出`StackOverflowError`异常；
  + 如果虚拟机栈可以动态扩展时，扩展无法申请到足够的内存时会抛出`OutOfMemoryError`；
3. **本地方法栈Native Method Stack**:本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行`Native方法服务`;
4. **Java 堆 Heap**:Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。**几乎所有的对象实例以及数组都要在堆上分配;**由于现在GC基本都采用分带动收集算法，Java堆内存可以再细分：
  + 新生代：`Eden空间`、`From Survivor空间`、`To Survivor空间`；
  + 老年代；
  + 通过`-Xmx`和`-Xms`控制Java堆内存大小；
  + 当堆无法再扩展时，将会抛出`OutOfMemoryError`异常；
  + Java堆可以处于物理上不连续内存空间中，只要逻辑上是连续的即可；
5. **方法区Method Area**:与Java堆一样，被各个线程所共享，**存放了已被虚拟机加载的类信息（名称、修饰符等）、常量、静态常量、即时编译器后的代码等数据**；
  + 在HotSpot虚拟机中存在永久代内存区域；
  + 运行时常量池（Runtime Constant Pool）是方法区的一部分，用于存放编译期生成的各种字面量和符号引用；
  + 运行时常量池具备动态性，如`String`类的`intern（）`方法；


在JMM中我们可以知道JVM工作的单元是线程，每个线程都有自己工作内存，且不同线程之间共享主内存。而主内存JVM中主要代表是`Java堆内存`；

## 对象访问
>在Java语言中，对象访问是如何进行的？
对象访问在Java语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会涉及Java栈、Java堆、方法区这三哥哥最重要内存区域之间的关联关系；

```
Object obj = new Object();
```

>如上述代码出现在方法体中，
+ `Object obj` 这部分语义将会反映到**`Java栈的本地变量表`**中，作为一个`reference`类型数据出现。
+ `new Object()` 这部分的语义将会反映到`Java堆`中，形成一块存储了`Object`类型所有实例数据值(`Instance Data，对象中各个实例字段的数据`)的结构化内存，根据具体类型以及虚拟机实现的对象内存布局的不同，这块内存长度是不固定的。

***(由于reference类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过那种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针)***

### 访问方式

>1. **使用句柄**：Java堆中将会划出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自具体地址信息； 


## Java堆内存

JVM中所划分的内存区域，Java程序中我们主要使用到堆内存，其他内存区域对程序隔离，交由JVM内部调用；

JVM为了处理堆内存内对象（内存回收），进行抽象性划分堆内存区域：


## 问题

**“你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？”**

>在什么时候：
1. 新生代有一个`Eden区`和`两个survivor区`，首先将对象放入`Eden区`，如果空间不足就向其中的一个`survivor区`上放，如果仍然放不下就会引发一次发生在`新生代的minor GC`，将存活的对象放入另一个`survivor区`中，然后清空Eden和之前的那个`survivor区`的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。
2. 大对象以及长期存活的对象直接进入老年区。
3. 当每次执行`minor GC`的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。

>对什么东西：
+ 从`GC Roots`搜索不到，而且经过一次标记清理之后仍没有复活的对象。

>做什么：
1. 新生代：复制清理；
2. 老年代：标记-清除和标记-压缩算法；
3. 永久代：存放Java中的类和加载类的类加载器本身。


**GC Roots都有哪些：**
>1. 虚拟机栈中的引用的对象
2. 方法区中静态属性引用的对象，常量引用的对象
3. 本地方法栈中JNI（即一般说的`Native方法`）引用的对象。