# 顺序一致性

## 数据竞争与顺序一致性

当程序未正确同步是，就可能会存在数据竞争。java内存模型规范对数据竞争的定义如下：
1. 在一个线程中写一个变量；
2. 在另一个线程读同一个变量；
3. 而且写和读没有通过同步来排序；

***(当代码中包含数据竞争时，程序的执行往往产生违反直觉的结果)***

>JMM对正确同步的多线程程序的内存一致性做了如下保证：
* 如果程序是正确同步的，程序的执行将具有顺序一致性（sequentially consistent）--即程序的执行结果与该程序在顺序一致性内存模型中执行结果相同；

## 顺序一致性内存模型

>* 一个线程中的所有操作必须按照程序的顺序来执行；
* （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见；

***（在概念上，顺序一致性内存模型有一个单一的全局内存，这个内存通过一个左右摆动的开关可以连接到任意一个线程，同时每一个线程必须按照程序的顺序来执行内存读
/写操作）***

### 同步程序的顺序一致性效果

通过锁来同步，监视临界区的代码。
在JMM中，临界区内的代码可以重排序（JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。 JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图。

### 未同步程序的执行特性

对于未同步或未正确同步的多线程程序， JMM只提供最小安全性：***线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0， null，false）***，JMM保证线程读操作读取到的值不会无中生有。

>未同步程序在JMM中的执行时，整体上是无序的，程序在两个模型中的执行特性有相应差异：
1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行。
2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。
3. JMM不保证对64位的long型和double型变量的读/写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。

***(第三个差异与处理器总线的工作机制密切相关，在一些32位的处理器上，如果要求对64位数据的写操作具有原子性，会有比较大的开销。为了照顾这中处理器，java语言规范鼓励但不强求JVM对64位的long型变量和double型变量的写具有原子性)***

***(当JVM运行在32位处理器是，会把一个64位long/double型变量的写操作拆分位两个32位的写操作来执行)***