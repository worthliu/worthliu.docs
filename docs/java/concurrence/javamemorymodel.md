## 并发编程所带来的问题

>并发编程中，有两个关键问题**（*线程指并发执行的活动实体*）**：
1. 线程之间如何**通信**；
2. 线程之间如何**同步**；


>**通信是指线程之间以何种机制来交换信息。**
1. 共享内存，线程之间共享程序的公共状态，**线程之间通过写-读内存中的公共状态来隐式进行通信**；
2. 消息传递，**线程之间必须通过明确的发送消息来显式进行通信**；


>**同步是指程序用于控制不同线程之间操作发生相对顺序的机制。**
1. 共享内存，同步是显式进行的，程序必须显式指定某个方法或某段代码需要在线程之间互斥执行；
2. 消息传递，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的；

## JVM内存结构
进入JMM前，我们先行观察JDK为Java程序运行所打造的运行时数据区域，**JVM内存结构**：
>***JVM在执行Java程序的过程中，会把它管理的内存划分为几个不同的数据区域，这些区域都有各自的用途、创建时间、销毁时间***

![JVM Memory Structure](/images/jvmmemorystructure.png)

>1. **程序计数器**：用于保存当前正在执行的程序的内存地址,每个线程都有一个独立计数器,线程所有,线程安全;
2. **Java栈**: JVM就会为该线程创建对应的Java栈，在这个Java栈中又会包含多个栈帧(Stack Frame)，这些栈帧是与每个方法关联起来的，每运行一个方法就创建一个栈帧，每个栈帧会**含有一些局部变量、操作栈和方法返回值等信息**。程序计数器也会指向该地址;(-Xss:设置栈的大小)
3. **堆 Heap**:堆是存储Java对象的地方,为所有线程共享;所有的对象实例以及数组都要在堆上分配;（-Xmx -Xms：设置堆内存最大运行内存大小）
4. **方法区Method Area**:存放了要加载的类的信息（名称、修饰符等）、类中的静态常量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当在程序中通过Class对象的getName.isInterface等方法来获取信息时，这些数据都来源于方法区。
5. **本地方法栈Native Method Stack**:本地方法栈和Java栈所发挥的作用非常相似，区别不过是Java栈为JVM执行Java方法服务，而本地方法栈为JVM执行Native方法服务。

简单了解一下JVM内存结构，我们可以发现其中主要反复提到**线程、线程共享的内存**；


## Java内存模型（JMM）

从上述JVM内存结构中，我们知道java程序运行时主要的工作单元是线程，且多个线程运行是相互不受影响的，但是对于一个程序而言运行过程中线程间必然需要相互通讯；

那么什么时间通讯、怎么通讯就交由JMM进行处理；

>JMM定义了程序中各个变量的访问规则，即在JVM中将变量存储到内存和从内存中取出变量这样的底层细节

>1. 所有的变量都存储在主内存（Main Memory）中;
2. 每个线程有自己的工作内存（Working Memory）,线程的工作内存中保存了该线程使用到的变量，变量是为主内存的副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量;
3. 不同的线程之间也无法直接访问对方工作内存中的变量，线程之间值的传递都需要通过主内存来完成。

从上述描述，JMM更多的是一种抽象概念，其描述的是一组规则，通过这组规则控制程序中各个变量在共享数据区域和私有数据区域的访问方式；用来***解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题***；

>* 在java中，所有实例域、静态域和数组元素存储在堆内存中，堆内存在线程之间共享；**局部变量（Local variables）、方法定义参数和异常处理器参数**不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响；
* Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见；

抽象看待，JMM定义了线程和主内存之间的抽象关系：
> **线程之间的共享变量存储在主内存(main memory)中，每个线程都有一个私有的本地内存(local memory)，本地内存中存储了该线程以读/写共享变量的副本**。

*(本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化)*

![JMM](/images/javamemorymodel.png)

### happens-before
JMM除了主要规则外，还形成了happens-before规则来帮助完成线程之间的同步、通讯；

从JDK5开始，java使用新的JSR-133内存模型，JSR-133使用happens-before的概念来阐述操作之间的内存可见性。
***(JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须要存在happens-before关系)***

>1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作；
2. 监视器锁规则：对一个监视器的解锁，happens-before于随后对这个监视器的加锁；
3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读；
4. 传递性：如果A happens-before B， 且B happens-before C，那么A happens-before C；

***(两个操作之间具有happens-before关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before仅仅要求前一个操作哦（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。)***
![happens-before](/images/happens-before.png)

### 重排序

在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。
>重排序三种类型：
1. **编译器优化的重排序**，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序；
2. **指令级并行的重排序**，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序；
3. **内存系统的重排序**，由于处理器使用缓存和读/写缓冲区，使得加载和存储操作看上去可能是在乱序执行；

*(对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序；对于处理器重排序，JMM的处理器重排序规则会要求Java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序)*

![javareorder](/images/javareorder.png)

**指令重排只会保证单线程中串行语义的执行的一致性，但并不会关心多线程间的语义一致性**

### 处理器重排序与内存屏障指令

* 现代的处理器使用写缓冲区来临时保存向内存写入的数据。
* 写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。
* 同时，通过以批处理的方式刷新写缓冲区，以及合并写缓冲区中对同一内存地址的多次写，可以减少对内存总线的占用。
* 虽然写缓冲区有这么多好处，但每个处理器上的写缓冲区，仅仅对它所在的处理器可见。这个特性会对内存操作的执行顺序产生重要的影响：**处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致！**


为了保证**内存可见性**，java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序。
JMM把内存屏障指令分为四类：
>
屏障类型|指令示例|说明|
---|---|---|
LoadLoad Barriers|Load1;LoadLoad;Load2|确保Load1数据的装载，之前于Load2及所有后续装载指令的装载|
StoreStore Barriers|Store1;StoreStore;Store2;|确保Store1数据对其他处理器可见（刷新到内存），之前于Store2及所有后续存储指令的存储；|
LoadStore Barriers|Load1；LoadStore；Store2；|确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到到内存；|
StoreLoad Barriers|Store1；StoreLoad；Load2；|确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令；|


## JMM目的与实现

### JMM目的

JMM是围绕着在线程并发过程中如何处理可见性、原子性、有序性这三个特性而建立的模型；

>1. **原子性**：一个操作不能被打断，要么全部执行完毕，要么不执行（重排序）；
2. **有序性**：在本线程内观察，操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的；
3. **可见性**：一个线程对共享变量做了修改之后，其他的线程立即能够看到（感知到）该变量这种修改（变化）；



### JMM实现

>* 使用`synchronized`关键字或者可重入锁（`ReentrantLock`）保证程序执行中方法级或者代码块级别的的原子性操作；
* 工作内存与主内存同步延迟现象导致的可见性问题，可以使用`synchronized`关键字或者`volatile`关键字解决，它们都可以使一个线程修改后的变量立即对其他线程可见；
* 对于指令重排序导致的可见性问题和有序性问题，可以利用`volatile`关键字解决；
* happens-before原则来保证多线程环境下两个操作间的原子性、可见性和有序性；
