# hashCode And equals

## hashCode与equals的作用与区别及应当注意的细节

**先来试想一个场景，如果你想查找一个集合中是否包含某个对象，那么程序应该怎么写呢？**
>+ 通常的做法是逐一取出每个元素与要查找的对象一一比较，当发现两者进行`equals`比较结果相等时，则停止查找并返回`true`，否则，返回`false`。
+ 但是这个做法的一个缺点是**当集合中的元素很多时，譬如有一万个元素，那么逐一的比较效率势必下降很快**。
+ 于是有人发明了一种`哈希算法`来提高从该集合中查找元素的效率，这种方式将集合分成若干个存储区域（可以看成一个个桶），每个对象可以计算出一个哈希码，可以根据`哈希码分组`，每组分别对应某个存储区域，这样一个对象根据它的`哈希码`就可以分到不同的`存储区域（不同的桶中）`。

![hash](/images/hash.png)                

实际的使用中，一个对象一般有`key`和`value`，可以根据`key`来计算它的`hashCode`。

假设现在全部的对象都已经根据自己的`hashCode值`存储在不同的`存储区域`中了，那么现在查找某个对象（根据对象的key来查找），不需要遍历整个集合了，现在只需要计算要查找对象的key的`hashCode`，然后找到该`hashCode`对应的存储区域，在该存储区域中来查找就可以了，这样效率也就提升了很多。


>+ `hashCode`是为了**提高在散列结构存储中查找的效率，在线性表中没有作用**。
+ `equals`和`hashCode`需要**同时覆盖**。
+ 若两个对象`equals`返回`true`，则`hashCode`**有必要**也返回相同的`int数`。
+ 若两个对象`equals`返回`false`，则`hashCode`**不一定**返回不同的`int数`,但为**不相等的对象**生成不同`hashCode`值可以提高哈希表的性能。
+ 若两个对象`hashCode`返回**相同**`int数`，则`equals`**不一定**返回`true`。
+ 若两个对象`hashCode`返回**不同**`int数`，则`equals`**一定返回**`false`。
+ 同一对象在执行期间若已经存储在集合中，则不能修改影响`hashCode`值的相关信息，否则**会导致内存泄露问题**。

## hashCode和equals的区别和联系

**首先说明一下JDK对`equals(Object obj)`和`hashCode()`这两个方法的定义和规范：**
>在Java中任何一个对象都具备`equals(Object obj)`和`hashCode()`这两个方法，因为他们是在`Object类`中定义的。
  + `equals(Object obj)`方法**用来判断两个对象是否“相同”**，如果“相同”则返回true，否则返回false。
  + `hashCode()`方法返回**一个int数**，在`Object类`中的默认实现是**“将该对象的内部地址转换成一个整数返回”**。 

>`hashCode` 的常规协定是：     
  1. 在 Java 应用程序执行期间，在同一对象上多次调用 `hashCode` 方法时，必须一致地返回相同的整数，前提是对象上 `equals` 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。     
  2. 如果根据 `equals(Object)` 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 `hashCode` 方法都必须生成相同的整数结果。     
  3. 以下情况不是必需的：如果根据`equals(java.lang.Object)`方法，两个对象不相等，那么在两个对象中的任一对象上调用`hashCode`方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。     
  4. 实际上，由 `Object` 类定义的 `hashCode` 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 `JavaTM` 编程语言不需要这种实现技巧。）   
  5. 当`equals方法`被重写时，通常有必要重写 `hashCode 方法`，以维护 `hashCode方法`的常规协定，该协定声明相等对象必须具有相等的哈希码。

**一般来说涉及到对象之间的比较大小就需要重写equals方法，但是为什么第一点说重写了equals就需要重写hashCode呢？**

>+ **实际上这只是一条规范，如果不这样做程序也可以执行，只不过会隐藏bug。**
+ 一般一个类的对象如果会存储在HashTable，HashSet,HashMap等散列存储结构中，那么重写equals后最好也重写hashCode，否则会导致存储数据的不唯一性（存储了两个equals相等的数据）。
+ 而如果确定不会存储在这些散列结构中，则可以不重写hashCode。但是个人觉得还是重写比较好一点，谁能保证后期不会存储在这些结构中呢，况且重写了hashCode也不会降低性能，因为在线性结构（如ArrayList）中是不会调用hashCode，所以重写了也不要紧，也为后期的修改打了补丁。