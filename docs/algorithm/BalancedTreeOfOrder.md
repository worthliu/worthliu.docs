### B树(平衡多路搜索树) 

`B树`中所有结点中孩子结点个数的最大值成为`B树`的阶，通常用`m`表示，从查找效率考虑，一般要求`m>=3`。

一棵`m阶B树`或者是一棵空树，或者是满足以下条件的`m叉树`。
1. 每个结点最多有m个分支(子树)；
  + 而最少分支数要看是否为根结点，如果是根结点且不是叶子结点，则至少要有两个分支，非根非叶结点至少有`ceil(m/2)`个分支，这里`ceil`代表向上取整。
2. 如果一个结点有`n-1`个关键字，那么该结点有`n`个分支。这`n-1`个关键字按照递增顺序排列。
3. 所有的叶子结点都位于同一层;
4. 除了根节点以外的所有结点(不包括叶子结点)的孩子正好是值个数的加1;
5. 每个结点中的值都按照从小到大的顺序排列,每个值的左子树的所有的值都小于它,而右子树中的所有的值都大于它;
6. 每个非根节点所包含的关键字个数`j`满足：`┌m/2┐ - 1 <= j <= m - 1`

### `B树`的查找操作
`B树`的查找很简单，是二叉排序树的扩展，二叉排序树是二路查找，`B树`是多路查找，因为`B树`结点内的关键字是有序的，在结点内进行查找时除了顺序查找外，还可以用折半查找来提升效率。

`B树`的具体查找步骤如下(假设查找的关键字为key）：
1. 先让key与根结点中的关键字比较，如果key等于`k[i]`(k[]为结点内的关键字数组)，则查找成功
2. 若`key<k[1]`，则到`p[0]`所指示的子树中进行继续查找(`p[]`为结点内的指针数组. ，这里要注意`B树`中每个结点的内部结构。
3. 若`key>k[n]`，则道`p[n]`所指示的子树中继续查找。
4. 若`k[i]<key<k[i+1]`，则沿着指针`p[I]`所指示的子树继续查找。
5. 如果最后遇到空指针，则证明查找不成功。

