# 常用排序算法总结

> 排序算法往往指的是内部排序算法,即数据记录在内存中进行排序
1. 比较排序,时间复杂度O(nlogn)~O(n^2),主要有:**冒泡排序,选择排序,插入排序,归并排序,堆排序,快速排序等**;
2. 非比较排序,时间复杂度可以达到O(n),主要有:**计数排序,基数排序,桶排序等**;

---


排序方法|平均情况|最好情况|最坏情况|辅助空间|稳定性|
--:|--:|--:|--:|--:|--:|
冒泡排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
简单选择排序|O(n^2)|O(n^2)|O(n^2)|O(1)|不稳定|
直接插入排序|O(n^2)|O(n)|O(n^2)|O(1)|稳定|
希尔排序|O(nlogn)~O(n2)|O(n^1.3)|O(n^2)|O(1)|稳定|
堆排序|O(nlogn)|O(nlogn)|O(nlogn)|O(1)|不稳定|
归并排序|O(nlogn)|O(nlogn)|O(nlogn)|O(n)|稳定|
快速排序|O(nlogn)|O(nlogn)|O(n^2)|O(logn)~O(n)|不稳定|

>排序算法稳定性的简单形式化定义为：
* 如果Ai = Aj，排序前Ai在Aj之前，排序后Ai还在Aj之前，则称这种排序算法是稳定的；
* 通俗地讲就是保证排序前后两个相等的数的相对顺序不变；


### 冒泡排序(Bubble Sort)

>重复地遍历所有要排序的元素，依次比较相邻两个元素，如果它们的顺序错误就调换位置，直到没有元素再需要交换，排序完成。
>>1. 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。
2. 每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


